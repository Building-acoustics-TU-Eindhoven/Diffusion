

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>acousticDE.FiniteVolumeMethod.FVMfunctions &mdash; Diffusion Equation for Acoustics 0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=2709fde1"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            Diffusion Equation for Acoustics
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Software Presentation:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../Overview.html">Overview</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Software Use:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../Finite%20Different%20Method%20Use.html">Finite Different Method Use</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Finite%20Volume%20Method%20Use.html">Finite Volume Method Use</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Auralization%20Use.html">Auralization Use</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Software Theory:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../DocumentationFDM.html">Diffusion Equation Finite Different Method (FDM) documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../DocumentationFVM.html">Diffusion Equation Finite Volume Method (FVM) Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../DocumentationAuralization.html">Auralization Documentation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API reference:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../acousticDE/FDMfunctions.html">FDM functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../acousticDE/FVMfunctions.html">FVM functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../acousticDE/ReverberationFunctions.html">Reverberation functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../acousticDE/Auralizationfunctions.html">Auralization functions</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tutorials:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../Finite%20Different%20Method%20Demo%20Tutorial.html">Finite Different Method Demo Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Finite%20Volume%20Method%20Demo%20Tutorial.html">Finite Volume Method Demo Tutorial</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Diffusion Equation for Acoustics</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">acousticDE.FiniteVolumeMethod.FVMfunctions</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for acousticDE.FiniteVolumeMethod.FVMfunctions</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Created on Wed Aug  2 16:12:40 2023</span>

<span class="sd">@author: Ilaria Fichera</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1">#%%</span>
<span class="c1">###############################################################################</span>
<span class="c1">#IMPORT LIBRARIES</span>
<span class="c1">###############################################################################</span>
<span class="c1">#Code developed by Ilaria Fichera for the analysis of the FVM method adapted solving the 3D diffusion equation with one intermittent omnidirectional sound source</span>
<span class="c1">#Import modules</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">math</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pickle</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">time</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">types</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">math</span><span class="w"> </span><span class="kn">import</span> <span class="n">ceil</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">math</span><span class="w"> </span><span class="kn">import</span> <span class="n">log</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">gmsh</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">acousticDE.FiniteVolumeMethod.FunctionClarity</span><span class="w"> </span><span class="kn">import</span> <span class="n">clarity</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">acousticDE.FiniteVolumeMethod.FunctionDefinition</span><span class="w"> </span><span class="kn">import</span> <span class="n">definition</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">acousticDE.FiniteVolumeMethod.FunctionCentreTime</span><span class="w"> </span><span class="kn">import</span> <span class="n">centretime</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">acousticDE.FiniteVolumeMethod.FunctionRT</span><span class="w"> </span><span class="kn">import</span> <span class="n">t60_decay</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>

<span class="c1"># Create logger for this module</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="c1">#%%</span>
<span class="c1">###############################################################################</span>
<span class="c1">#SURFACE MATERIALS FUNCTIONS</span>
<span class="c1">###############################################################################</span>

<div class="viewcode-block" id="number_freq">
<a class="viewcode-back" href="../../../acousticDE/FVMfunctions.html#acousticDE.FiniteVolumeMethod.FVMfunctions.number_freq">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">number_freq</span><span class="p">(</span><span class="n">num_octave</span><span class="p">,</span><span class="n">fc_high</span><span class="p">,</span><span class="n">fc_low</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the frequency array and the number of frequency bands.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    num_octave : int</span>
<span class="sd">        Number of octaves to calculate (1 or 3 octaves).</span>
<span class="sd">    fc_high : int</span>
<span class="sd">        The highest frequency in the calculation.</span>
<span class="sd">    fc_low : int</span>
<span class="sd">        The lowest frequency in the calculation.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    nBands : int</span>
<span class="sd">        Number of frequency bands.</span>
<span class="sd">    center_freq : list of float</span>
<span class="sd">        Array of all the frequencies to calculate.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x_frequencies</span>  <span class="o">=</span> <span class="n">num_octave</span> <span class="o">*</span> <span class="n">log</span><span class="p">(</span><span class="n">fc_high</span><span class="o">/</span><span class="n">fc_low</span><span class="p">)</span> <span class="o">/</span> <span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">nBands</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">num_octave</span> <span class="o">*</span> <span class="n">log</span><span class="p">(</span><span class="n">fc_high</span><span class="o">/</span><span class="n">fc_low</span><span class="p">)</span> <span class="o">/</span> <span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">center_freq</span> <span class="o">=</span> <span class="n">fc_low</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">2</span><span class="p">,((</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">x_frequencies</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">num_octave</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">nBands</span><span class="p">,</span> <span class="n">center_freq</span></div>



<span class="c1"># Absorption term for boundary conditions </span>
<div class="viewcode-block" id="abs_term">
<a class="viewcode-back" href="../../../acousticDE/FVMfunctions.html#acousticDE.FiniteVolumeMethod.FVMfunctions.abs_term">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">abs_term</span><span class="p">(</span><span class="n">th</span><span class="p">,</span><span class="n">abscoeff_list</span><span class="p">,</span><span class="n">c0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the absorption term (Sabine, Eyring or Modified)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        th : int</span>
<span class="sd">            The options for the absorption term; Sabine (th=1), Eyring (th=2) and modified by Xiang (th=3)</span>
<span class="sd">        abscoeff_list : list</span>
<span class="sd">            Absrption coefficient for each frequency</span>
<span class="sd">        c0 : int </span>
<span class="sd">            Speed of sound </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        Absx_array : array of floats</span>
<span class="sd">            Calculated absorption term for each absorption coefficient for each frequency</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Absx_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
    <span class="k">for</span> <span class="n">abs_coeff</span> <span class="ow">in</span> <span class="n">abscoeff_list</span><span class="p">:</span>
        <span class="c1">#print(abs_coeff)</span>
        <span class="k">if</span> <span class="n">th</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">Absx</span> <span class="o">=</span> <span class="p">(</span><span class="n">c0</span><span class="o">*</span><span class="n">abs_coeff</span><span class="p">)</span><span class="o">/</span><span class="mi">4</span> <span class="c1">#Sabine</span>
        <span class="k">elif</span> <span class="n">th</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">Absx</span> <span class="o">=</span> <span class="p">(</span><span class="n">c0</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">abs_coeff</span><span class="p">)))</span><span class="o">/</span><span class="mi">4</span> <span class="c1">#Eyring</span>
        <span class="k">elif</span> <span class="n">th</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">Absx</span> <span class="o">=</span> <span class="p">(</span><span class="n">c0</span><span class="o">*</span><span class="n">abs_coeff</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">-</span><span class="n">abs_coeff</span><span class="p">))</span> <span class="c1">#Modified by Xiang</span>
        <span class="n">Absx_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Absx_array</span><span class="p">,</span> <span class="n">Absx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Absx_array</span></div>


<div class="viewcode-block" id="create_vgroups_names">
<a class="viewcode-back" href="../../../acousticDE/FVMfunctions.html#acousticDE.FiniteVolumeMethod.FVMfunctions.create_vgroups_names">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">create_vgroups_names</span><span class="p">(</span><span class="n">file_path</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a list of the material names assigned in SketchUp</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        file_path : str</span>
<span class="sd">            Full path to the mesh file</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        vGroupsNames : list</span>
<span class="sd">            Names of the materials in the msh file (the material name are the same as the one assigned in the SketchUp file)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">gmsh</span><span class="o">.</span><span class="n">initialize</span><span class="p">()</span> <span class="c1">#Initialize msh file</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">gmsh</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span> <span class="c1">#open the file</span>
    <span class="n">dim</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="c1">#dimensions of the entities, 0 for points, 1 for curves/edge/lines, 2 for surfaces, 3 for volumes, -1 for all the entities </span>
    <span class="n">tag</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="c1">#all the nodes of the room</span>
    <span class="n">vGroups</span> <span class="o">=</span> <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">getPhysicalGroups</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1">#these are the entity tag and physical groups in the msh file. </span>
    <span class="n">vGroupsNames</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1">#these are the entity tag and physical groups in the msh file + their names</span>
    <span class="k">for</span> <span class="n">iGroup</span> <span class="ow">in</span> <span class="n">vGroups</span><span class="p">:</span>
        <span class="n">dimGroup</span> <span class="o">=</span> <span class="n">iGroup</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1">#entity tag: 1 lines, 2 surfaces, 3 volumes (1D, 2D or 3D)</span>
        <span class="n">tagGroup</span> <span class="o">=</span> <span class="n">iGroup</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1">#physical tag group (depending on material properties defined in SketchUp)</span>
        <span class="n">namGroup</span> <span class="o">=</span> <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">getPhysicalName</span><span class="p">(</span><span class="n">dimGroup</span><span class="p">,</span> <span class="n">tagGroup</span><span class="p">)</span> <span class="c1">#names of the physical groups defined in SketchUp   </span>
        <span class="n">alist</span> <span class="o">=</span> <span class="p">[</span><span class="n">dimGroup</span><span class="p">,</span><span class="n">tagGroup</span><span class="p">,</span><span class="n">namGroup</span><span class="p">]</span> <span class="c1">#creates a list of the entity tag, physical tag group and name</span>
        <span class="c1">#print(alist)</span>
        <span class="n">vGroupsNames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">alist</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">vGroupsNames</span></div>


<span class="c1"># Gives absorption coefficients to a material (group) and links it to the surfaces</span>
<div class="viewcode-block" id="surface_materials">
<a class="viewcode-back" href="../../../acousticDE/FVMfunctions.html#acousticDE.FiniteVolumeMethod.FVMfunctions.surface_materials">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">surface_materials</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">abscoeff</span><span class="p">,</span> <span class="n">surface_absorption</span><span class="p">,</span> <span class="n">absorption_coefficient_dict</span><span class="p">,</span> <span class="n">nBands</span><span class="p">,</span><span class="n">th</span><span class="p">,</span><span class="n">c0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of absorption term for each material</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        group : list</span>
<span class="sd">            List of element type (1 for lines, 2 for surface, 3 for volumes), element type number and material name in the msh file</span>
<span class="sd">        abscoeff : list of strings</span>
<span class="sd">            Absorption coefficient of the group (material name)</span>
<span class="sd">        surface_absorption : list of tuples</span>
<span class="sd">            List initialization for each frequency of a tuple including the surface number and the absorption term for that surface</span>
<span class="sd">        absorption_coefficient_dict : dict</span>
<span class="sd">            Dictionary initialization of absorption coefficients per each surface and per each frequency </span>
<span class="sd">        nBands : int</span>
<span class="sd">            Number of frequency bands</span>
<span class="sd">        th : int</span>
<span class="sd">            Option for the absorption term; Sabine (th=1), Eyring (th=2) and modified by Xiang (th=3)</span>
<span class="sd">        c0 : int</span>
<span class="sd">            Speed of sound </span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">        Exception: If the number of absorption coefficient typed are higher than the number of frequency bands it will raise an error</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        absorption_coefficient_dict : dict</span>
<span class="sd">            absorption coefficients per each surface and per each frequency</span>
<span class="sd">        surface_absorption : list of tuples</span>
<span class="sd">            Absorption term for each surface and for each frequency</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">#abscoeff = abscoeff.split(&quot;,&quot;)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">abscoeff</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nBands</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Number of absorption coefficients doesn&#39;t match the number of frequency bands&quot;</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Number of absorption coefficients doesn&#39;t match the number of frequency bands&quot;</span><span class="p">)</span>

    <span class="c1">#abscoeff = [float(i) for i in abscoeff][-1] #for one frequency</span>
    <span class="n">abscoeff_list</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">abscoeff</span><span class="p">]</span> <span class="c1">#for multiple frequencies</span>
    
    <span class="n">physical_tag</span> <span class="o">=</span> <span class="n">group</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c1">#Get the physical group tag</span>
    <span class="n">entities</span> <span class="o">=</span> <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">getEntitiesForPhysicalGroup</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">physical_tag</span><span class="p">)</span> <span class="c1">#Retrieve all the entities in this physical group (the entities are the number of walls in the physical group)</span>

    <span class="n">Abs_term</span> <span class="o">=</span> <span class="n">abs_term</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">abscoeff_list</span><span class="p">,</span><span class="n">c0</span><span class="p">)</span> <span class="c1">#calculates the absorption term based on the type of boundary condition th</span>
    <span class="k">for</span> <span class="n">entity</span> <span class="ow">in</span> <span class="n">entities</span><span class="p">:</span>
        <span class="n">absorption_coefficient_dict</span><span class="p">[</span><span class="n">entity</span><span class="p">]</span> <span class="o">=</span> <span class="n">abscoeff_list</span>
        <span class="n">surface_absorption</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">entity</span><span class="p">,</span> <span class="n">Abs_term</span><span class="o">.</span><span class="n">copy</span><span class="p">()))</span> <span class="c1">#absorption term (alpha*surfaceofwall) for each wall of the room</span>
        <span class="n">surface_absorption</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">surface_absorption</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    
    <span class="k">return</span> <span class="n">absorption_coefficient_dict</span><span class="p">,</span> <span class="n">surface_absorption</span></div>


<span class="c1">#%%</span>
<span class="c1">###############################################################################</span>
<span class="c1">#GMSH GET NODES, VOLUME ELEMENTS AND BOUNDARY ELEMENTS</span>
<span class="c1">###############################################################################</span>
<div class="viewcode-block" id="get_nodes_elem">
<a class="viewcode-back" href="../../../acousticDE/FVMfunctions.html#acousticDE.FiniteVolumeMethod.FVMfunctions.get_nodes_elem">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_nodes_elem</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span><span class="n">tag</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the number of volumetric and boundary elements in the mesh</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        dim : int </span>
<span class="sd">            Dimensions of the entities, 0 for points, 1 for curves/edge/lines, 2 for surfaces, 3 for volumes, -1 for all the entities </span>
<span class="sd">        tag : int</span>
<span class="sd">            Indication for nodes (-1 indicates all the nodes of the room) </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        nodecoords : array of floats</span>
<span class="sd">            The coordinates of each node in the mesh</span>
<span class="sd">        node_indices : dict </span>
<span class="sd">            Indeces of all the nodes in the mesh</span>
<span class="sd">        bounEl : array of int </span>
<span class="sd">            Indeces of all the boundary surfaces in the mesh</span>
<span class="sd">        bounNode : array of int </span>
<span class="sd">            Indeces of all the boundary nodes per each boundary surface in the mesh</span>
<span class="sd">        voluEl : array of int</span>
<span class="sd">            Indeces of all the bolume elements (tetrahedra) in the mesh</span>
<span class="sd">        voluNode : array of int </span>
<span class="sd">            Indeces of all the volumetric nodes per each colume element in the mesh</span>
<span class="sd">        belemNodes : array of int</span>
<span class="sd">            Indeces of all the boundary nodes per each boundary surface in the mesh</span>
<span class="sd">        velemNodes : array of int </span>
<span class="sd">            Indeces of all the volumetric nodes per each colume element in the mesh</span>
<span class="sd">        boundaryEl_dict : dict</span>
<span class="sd">            Dictionary with key the index of the boundary element (boudnary surface) and value the indeces of the nodes of the surface</span>
<span class="sd">        volumeEl_dict : dict </span>
<span class="sd">            Dictionary with key the index of the volumetric element (tetrahedra) and value the indeces of the nodes of the tetrahedra</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Nodes</span>
    <span class="c1">#tag = -1  # all the nodes of the room</span>
    <span class="n">nodeTags</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">parametricCoord</span> <span class="o">=</span> <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">getNodes</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span>
                                                                    <span class="n">tag</span><span class="p">)</span>  <span class="c1"># gets the tags for each node and the coordinates of each node</span>
    <span class="n">nodecoords</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>  <span class="c1"># coordinates reshaped in a matrix 3xnumber of nodes</span>

    <span class="n">node_indices</span> <span class="o">=</span> <span class="p">{</span><span class="n">tag</span><span class="p">:</span> <span class="n">index</span> <span class="k">for</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">tag</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nodeTags</span><span class="p">)}</span>

    <span class="c1"># Element Types</span>
    <span class="n">elemTypes</span><span class="p">,</span> <span class="n">elemTags</span><span class="p">,</span> <span class="n">elemNodeTags</span> <span class="o">=</span> <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">getElements</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">tag</span><span class="p">)</span>
    <span class="c1"># elemTypes = 1 for lines, 2 for surfaces, 4 for tetrahedron</span>
    <span class="c1"># elemTags =  list of list of lines, boundary elements (surfaces) and volume elements (tetrahedron)</span>
    <span class="c1"># elemNodeTags = did not understand this yet, probably a tag gives to each line, surface and tetrahedron</span>
    <span class="k">for</span> <span class="n">e_type</span> <span class="ow">in</span> <span class="n">elemTypes</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">e_type</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># if the e_type = 1, then get all the elements (lines) with that e_type</span>
            <span class="n">tag</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">edgeEl</span><span class="p">,</span> <span class="n">edgeNodeTagstype</span> <span class="o">=</span> <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">getElementsByType</span><span class="p">(</span><span class="n">e_type</span><span class="p">,</span>
                                                                            <span class="n">tag</span><span class="p">)</span>  <span class="c1"># get the edge element tags and the nodes; edgeEl are lines</span>
            <span class="c1"># edgeEl = numbered edge elements (lines)</span>
        <span class="k">elif</span> <span class="n">e_type</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># if the e_type = 2, then get all the elements (surfaces) with that e_type</span>
            <span class="n">tag</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">bounEl</span><span class="p">,</span> <span class="n">bounNodeTagstype</span> <span class="o">=</span> <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">getElementsByType</span><span class="p">(</span><span class="n">e_type</span><span class="p">,</span>
                                                                            <span class="n">tag</span><span class="p">)</span>  <span class="c1"># get the boundary/surface element tags and the nodes; bounEl are surfaces</span>
            <span class="n">bounNode</span> <span class="o">=</span> <span class="n">bounNodeTagstype</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
            <span class="c1"># boundEl = numbered boundary elements (surfaces)</span>
            <span class="c1"># bounNode = nodes of the surfaces</span>
        <span class="k">elif</span> <span class="n">e_type</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">tag</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>  <span class="c1"># if the e_type = 4, then get all the elements (tetrahedron) with that e_type</span>
            <span class="n">voluEl</span><span class="p">,</span> <span class="n">voluNodeTagstype</span> <span class="o">=</span> <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">getElementsByType</span><span class="p">(</span><span class="n">e_type</span><span class="p">,</span>
                                                                            <span class="n">tag</span><span class="p">)</span>  <span class="c1"># get the volume element tags and the nodes; voluEl are tetrahedrons</span>
            <span class="n">voluNode</span> <span class="o">=</span> <span class="n">voluNodeTagstype</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
            <span class="c1"># voluEl = numbered volume elements (tetrahedron)</span>
            <span class="c1"># voluNode = nodes of the tetrahedon</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The procedure is not possible&quot;</span><span class="p">)</span>

    <span class="n">velemNodes</span> <span class="o">=</span> <span class="n">elemNodeTags</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>  <span class="c1"># nodes per each tetrahedron</span>
    <span class="n">belemNodes</span> <span class="o">=</span> <span class="n">elemNodeTags</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>  <span class="c1"># nodes per each surface boundary</span>

    <span class="n">eelement</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">edgeEl</span><span class="p">)):</span>
        <span class="n">eelement</span> <span class="o">=</span> <span class="n">eelement</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># scalar number of the edge elements</span>

    <span class="c1"># Volume Element dictionary + nodes of each volume elements (4 nodes per element)</span>
    <span class="n">volumeEl_dict</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># Initialization Dictionary of volumelements + its nodes</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">voluEl</span><span class="p">)):</span>
        <span class="c1"># print(i)</span>
        <span class="n">volumeEl_dict</span><span class="p">[</span><span class="n">voluEl</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">velemNodes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>  <span class="c1"># Dictionary of volumelements + its nodes</span>

    <span class="c1"># Boundary Element dictionary + node per each surface elements (3 nodes per element)</span>
    <span class="n">boundaryEl_dict</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># Initialization Dictionary of boundary elements + its nodes</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bounEl</span><span class="p">)):</span>
        <span class="n">boundaryEl_dict</span><span class="p">[</span><span class="n">bounEl</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">belemNodes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>  <span class="c1"># Dictionary of boundary elements + its nodes</span>

    <span class="k">return</span> <span class="n">nodecoords</span><span class="p">,</span> <span class="n">node_indices</span><span class="p">,</span> <span class="n">bounEl</span><span class="p">,</span> <span class="n">bounNode</span><span class="p">,</span> <span class="n">voluEl</span><span class="p">,</span> <span class="n">voluNode</span><span class="p">,</span> <span class="n">belemNodes</span><span class="p">,</span> <span class="n">velemNodes</span><span class="p">,</span> <span class="n">boundaryEl_dict</span><span class="p">,</span> <span class="n">volumeEl_dict</span></div>



<span class="c1">#%%</span>
<span class="c1">###############################################################################</span>
<span class="c1">#CALCULATION OF VOLUME CELLS AND CENTRE OF VOLUME</span>
<span class="c1">###############################################################################</span>

<div class="viewcode-block" id="velem_volume_centre">
<a class="viewcode-back" href="../../../acousticDE/FVMfunctions.html#acousticDE.FiniteVolumeMethod.FVMfunctions.velem_volume_centre">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">velem_volume_centre</span><span class="p">(</span><span class="n">volumeEl_dict</span><span class="p">,</span><span class="n">nodecoords</span><span class="p">,</span><span class="n">node_indices</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of the volume of each cell and its center</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        volumeEl_dict : dict </span>
<span class="sd">            Dictionary with key the index of the volumetric element (tetrahedra) and value an array with the indeces of the nodes of the tetrahedra (maximum 4 indeces)</span>
<span class="sd">        nodecoords : array of floats </span>
<span class="sd">            The coordinates of each node in the mesh</span>
<span class="sd">        node_indices : dict</span>
<span class="sd">            Indeces of all the nodes in the mesh</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        cell_center : array of floats </span>
<span class="sd">            The coordinates of the center of the cell element per each element</span>
<span class="sd">        cell_volume : array of floats </span>
<span class="sd">            The volume of each element cell</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#Calculation of volume cells and centre of volume    </span>
    <span class="n">vcell_dict</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1">#volume of each element tetrahedron initialization</span>
    <span class="n">centre_cell</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1">#centre of the element tetrahedron initialization</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">volumeEl_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">coord_centre_cell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">centre_cell</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1">#print(i)</span>
        <span class="n">vc0</span> <span class="o">=</span> <span class="n">nodecoords</span><span class="p">[</span><span class="n">node_indices</span><span class="p">[</span><span class="n">volumeEl_dict</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]],:]</span> <span class="c1">#coordinates of node 0</span>
        <span class="c1">#vc0 = gmsh.model.mesh.getNode(volumeEl_dict[i][0])[0] #Coordinates of the node number zero of the volume element i</span>
        <span class="c1">#print(nc0)</span>
        <span class="n">vc1</span> <span class="o">=</span> <span class="n">nodecoords</span><span class="p">[</span><span class="n">node_indices</span><span class="p">[</span><span class="n">volumeEl_dict</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]],:]</span>
        <span class="n">vc2</span> <span class="o">=</span> <span class="n">nodecoords</span><span class="p">[</span><span class="n">node_indices</span><span class="p">[</span><span class="n">volumeEl_dict</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]],:]</span>
        <span class="n">vc3</span> <span class="o">=</span> <span class="n">nodecoords</span><span class="p">[</span><span class="n">node_indices</span><span class="p">[</span><span class="n">volumeEl_dict</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">3</span><span class="p">]],:]</span>
        <span class="c1">#vc1 = gmsh.model.mesh.getNode(volumeEl_dict[i][1])[0] #Coordinates of the node number one of the volume element i</span>
        <span class="c1">#print(nc1)</span>
        <span class="c1">#vc2 = gmsh.model.mesh.getNode(volumeEl_dict[i][2])[0] #Coordinates of the node number two of the volume element i</span>
        <span class="c1">#print(nc2)</span>
        <span class="c1">#vc3 = gmsh.model.mesh.getNode(volumeEl_dict[i][3])[0] #Coordinates of the node number three of the volume element i</span>
        <span class="c1">#print(nc3)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span> <span class="c1">#three coordinates per each node</span>
            <span class="n">coord_centre_cell</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">vc0</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="n">vc1</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="n">vc2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="n">vc3</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="o">/</span><span class="mi">4</span> <span class="c1">#coordinates of the centre of each volume element</span>
            <span class="n">centre_cell</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coord_centre_cell</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
        <span class="n">vcell_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">vc1</span><span class="o">-</span><span class="n">vc3</span><span class="p">,</span><span class="n">vc2</span><span class="o">-</span><span class="n">vc3</span><span class="p">),</span><span class="n">vc0</span><span class="o">-</span><span class="n">vc3</span><span class="p">))</span><span class="o">/</span><span class="mi">6</span> <span class="c1">#volume of each volume element</span>
    
    <span class="c1">#The dictionary centre cell is modified into an array of floats (list)</span>
    <span class="n">cell_center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(())</span> <span class="c1">#initialization of an array of centre cell coordinates from the centre_cell dictionary</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">centre_cell</span><span class="p">:</span>
        <span class="n">cell_center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cell_center</span><span class="p">,</span><span class="n">centre_cell</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
    <span class="n">cell_center</span> <span class="o">=</span> <span class="n">cell_center</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
    
    <span class="n">cell_volume</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(())</span> <span class="c1">#initialization of an array of cell volumes from the vcell_dict dictionary</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">vcell_dict</span><span class="p">:</span>
        <span class="n">cell_volume</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cell_volume</span><span class="p">,</span><span class="n">vcell_dict</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
    
    <span class="k">return</span> <span class="n">cell_center</span><span class="p">,</span> <span class="n">cell_volume</span></div>


<span class="c1">#%%</span>
<span class="c1">###############################################################################</span>
<span class="c1">#CALCULATION OF BOUNDARY ELEMENTS AND CENTRE OF AREA (might not need this function actually)</span>
<span class="c1">###############################################################################</span>
<span class="c1">#Calculation of boundary elements area and centre </span>
<div class="viewcode-block" id="belem_area_centre">
<a class="viewcode-back" href="../../../acousticDE/FVMfunctions.html#acousticDE.FiniteVolumeMethod.FVMfunctions.belem_area_centre">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">belem_area_centre</span><span class="p">(</span><span class="n">boundaryEl_dict</span><span class="p">,</span><span class="n">nodecoords</span><span class="p">,</span><span class="n">node_indices</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of the area of each boundary surface and its center</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        boundaryEl_dict : dict</span>
<span class="sd">            Dictionary with key the index of the boundary element (boudnary surface) and value an array with the indeces of the nodes of the surface (maximum 3 indeces)</span>
<span class="sd">        nodecoords : array of floats</span>
<span class="sd">            The coordinates of each node in the mesh</span>
<span class="sd">        node_indices : dict</span>
<span class="sd">            Indeces of all the nodes in the mesh</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        barea_dict : dict </span>
<span class="sd">            Area of each boundary surface element</span>
<span class="sd">        centre_area : dict </span>
<span class="sd">            Center point of each boundary surface element</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">barea_dict</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1">#surface of each element boundary initialization</span>
    <span class="n">centre_area</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1">#centre of the element tetrahedron initialization</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">boundaryEl_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">coord_centre_area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">centre_area</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1">#print(i)</span>
        <span class="n">bc0</span> <span class="o">=</span> <span class="n">nodecoords</span><span class="p">[</span><span class="n">node_indices</span><span class="p">[</span><span class="n">boundaryEl_dict</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]],:]</span>
        
        <span class="c1">#bc0 = gmsh.model.mesh.getNode(boundaryEl_dict[i][0])[0]</span>
        <span class="c1">#bnodeCoord_dict[boundaryEl_dict[i][0]] #Coordinates of the node number zero of the volume element i</span>
        <span class="c1">#print(nc0)</span>
        <span class="n">bc1</span> <span class="o">=</span> <span class="n">nodecoords</span><span class="p">[</span><span class="n">node_indices</span><span class="p">[</span><span class="n">boundaryEl_dict</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]],:]</span>
        <span class="c1">#gmsh.model.mesh.getNode(boundaryEl_dict[i][1])[0] #Coordinates of the node number one of the volume element i</span>
        <span class="c1">#print(nc1)</span>
        <span class="n">bc2</span> <span class="o">=</span> <span class="n">nodecoords</span><span class="p">[</span><span class="n">node_indices</span><span class="p">[</span><span class="n">boundaryEl_dict</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]],:]</span>
        <span class="c1">#gmsh.model.mesh.getNode(boundaryEl_dict[i][2])[0] #Coordinates of the node number two of the volume element i</span>
        <span class="c1">#print(nc2)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="n">coord_centre_area</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">bc0</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="n">bc1</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="n">bc2</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="o">/</span><span class="mi">3</span> <span class="c1">#coordinates of the centre of each volume element</span>
            <span class="n">centre_area</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coord_centre_area</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
        <span class="n">barea_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">bc2</span><span class="o">-</span><span class="n">bc1</span><span class="p">,</span><span class="n">bc1</span><span class="o">-</span><span class="n">bc0</span><span class="p">)))</span><span class="o">/</span><span class="mi">2</span> <span class="c1">#volume of each volume element</span>
    
    <span class="k">return</span> <span class="n">barea_dict</span><span class="p">,</span> <span class="n">centre_area</span></div>



<span class="c1">#%%</span>
<span class="c1">###############################################################################</span>
<span class="c1">#CALCULATION OF NEIGHBOURS (might not need this function actually)</span>
<span class="c1">###############################################################################</span>
<span class="c1">#Neighbours calculation; What are the neighbours faces of each volume? 3 per each minimum?</span>
<div class="viewcode-block" id="get_neighbour_faces">
<a class="viewcode-back" href="../../../acousticDE/FVMfunctions.html#acousticDE.FiniteVolumeMethod.FVMfunctions.get_neighbour_faces">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_neighbour_faces</span><span class="p">(</span><span class="n">voluEl</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of nighbours volumetric elements and faces</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        voluEl : array of int </span>
<span class="sd">            Indeces of all the volume elements (tetrahedra) in the mesh</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        fxt : dict </span>
<span class="sd">            Dictionary with keys as the nodes of each face and values the volume elements of which this face is neighbour</span>
<span class="sd">        txt : dict </span>
<span class="sd">            Dictionary with keys as the tetrahedron tag and values as the tet that are neighbours (the tet at the boundary are not counted)</span>
<span class="sd">        neighbourVolume : array of floats </span>
<span class="sd">            Array with the neighbours tetrahedron per each tetrahedron in order from 0 to the number of tetrahedrons</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">facenodes</span> <span class="o">=</span> <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">getElementFaceNodes</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span>
                                                    <span class="mi">3</span><span class="p">)</span>  <span class="c1"># 4 is the element type (tetrahedron) and three are the nodes per each face #get all the face tags of all the faces of the tetrahedrons</span>

    <span class="c1"># Computing face x tetrahedon incidence</span>
    <span class="n">faces</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># initialization of list of tuples of the faces nodes</span>
    <span class="n">fxt</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># dictionary with keys as the nodes of each face and values the volume elements of which this face is neighbour</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">facenodes</span><span class="p">),</span> <span class="mi">3</span><span class="p">):</span>  <span class="c1"># per each element basically, goes trhough the nodes of each face 3by3</span>
        <span class="c1"># print(i)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">facenodes</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]))</span>  <span class="c1"># nodes of each face put in a tuple from node i to node i plus 3</span>
        <span class="n">faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="n">tet</span> <span class="o">=</span> <span class="n">voluEl</span><span class="p">[</span><span class="n">i</span> <span class="o">//</span> <span class="mi">12</span><span class="p">]</span>  <span class="c1"># volume element number at which the faces are associated?</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fxt</span><span class="p">:</span>  <span class="c1"># if the face f (with its node) is already in the dictionary, just append the volume element neighbour to</span>
            <span class="n">fxt</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">tet</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fxt</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tet</span><span class="p">)</span>

    <span class="c1"># Computing neighbors by face</span>
    <span class="n">txt</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># dictionary with keys as the tetrahedron tag and values as the tet that are neighbours (the tet at the boundary are not counted)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">faces</span><span class="p">)):</span>
        <span class="c1"># print(i)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">faces</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>  <span class="c1"># f is a tuple of the nodes of the face into consideration</span>
        <span class="n">tet</span> <span class="o">=</span> <span class="n">voluEl</span><span class="p">[</span><span class="n">i</span> <span class="o">//</span> <span class="mi">4</span><span class="p">]</span>  <span class="c1"># tetrahedron at which the face is neighbour</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">tet</span> <span class="ow">in</span> <span class="n">txt</span><span class="p">:</span>  <span class="c1"># if the tet is not in the dictionary, add it, otherwise append the new tt</span>
            <span class="n">txt</span><span class="p">[</span><span class="n">tet</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">tt</span> <span class="ow">in</span> <span class="n">fxt</span><span class="p">[</span><span class="n">f</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">tt</span> <span class="o">!=</span> <span class="n">tet</span><span class="p">:</span>
                <span class="n">txt</span><span class="p">[</span><span class="n">tet</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">tt</span> <span class="o">-</span> <span class="p">(</span><span class="n">voluEl</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span>  <span class="c1"># volumes neighbours to each volume</span>
    <span class="k">for</span> <span class="n">values</span> <span class="ow">in</span> <span class="n">txt</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">:</span>  <span class="c1"># if there are less than 4 tetrahedron neighbours it means that the others are boundary tetrahedrons, therefore add a zero for each tetrahedron missing</span>
            <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">neighbourVolume</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">())</span>  <span class="c1"># initialization of an array with the neighbours tetrahedron per each tetrahedron in order from 0 to the number of tetrahedrons</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">txt</span><span class="p">:</span>
        <span class="n">neighbourVolume</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neighbourVolume</span><span class="p">,</span> <span class="n">txt</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">neighbourVolume</span><span class="p">:</span>
        <span class="n">item</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

    <span class="n">neighbourVolume</span> <span class="o">=</span> <span class="n">neighbourVolume</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
        <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>
            <span class="mi">4</span><span class="p">))</span>  <span class="c1"># reshape the array so that we have the 4 tetrahedrons neighbours of the tetrahedron in consideration</span>

    <span class="k">return</span> <span class="n">fxt</span><span class="p">,</span> <span class="n">txt</span><span class="p">,</span> <span class="n">neighbourVolume</span></div>


<span class="c1">#%%</span>
<span class="c1">###############################################################################</span>
<span class="c1">#CALCULATION OF INTERIOR TETRAHEDRONS</span>
<span class="c1">###############################################################################</span>
<span class="c1"># Interior Tetrahedrons calculations</span>

<div class="viewcode-block" id="interior_tetra">
<a class="viewcode-back" href="../../../acousticDE/FVMfunctions.html#acousticDE.FiniteVolumeMethod.FVMfunctions.interior_tetra">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">interior_tetra</span><span class="p">(</span><span class="n">voluEl</span><span class="p">,</span><span class="n">cell_center</span><span class="p">,</span><span class="n">velemNodes</span><span class="p">,</span><span class="n">nodecoords</span><span class="p">,</span><span class="n">node_indices</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of shared area divided shared distance between tetrahedrons</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        voluEl : array of int </span>
<span class="sd">            Indeces of all the bolume elements (tetrahedra) in the mesh</span>
<span class="sd">        cell_center : array of floats</span>
<span class="sd">            The coordinates of the center of the cell element per each element</span>
<span class="sd">        velemNodes : array of int </span>
<span class="sd">            Indeces of all the volumetric nodes per each colume element in the mesh</span>
<span class="sd">        nodecoords : array of floats </span>
<span class="sd">            The coordinates of each node in the mesh</span>
<span class="sd">        node_indices : dict </span>
<span class="sd">            Indeces of all the nodes in the mesh</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        interior_tet : array of floats</span>
<span class="sd">            Matrix of tetrahedron per tetrahedron of the division between shared area and shared distance</span>
<span class="sd">        interior_tet_sum : array of floats</span>
<span class="sd">            Sum of interior_tet per columns</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">interior_tet</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">voluEl</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">voluEl</span><span class="p">)))</span> <span class="c1">#initialization matrix of tetrahedron per tetrahedron</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">voluEl</span><span class="p">)):</span> <span class="c1">#for each tetrahedron, take its centre</span>
        <span class="c1">#print(i)</span>
        <span class="n">cell_center_i</span> <span class="o">=</span> <span class="n">cell_center</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">voluEl</span><span class="p">)):</span> <span class="c1">#for each tetrahedron, take its centre</span>
            <span class="c1">#cell_center_j = cell_center[j]</span>
            <span class="c1">#print(j)</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span> <span class="c1">#if the tetrahedrons are not the same one, then check if there are shared nodes in between the two tetrahedron i and j</span>
                <span class="n">shared_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">velemNodes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">velemNodes</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="c1">#shared_nodes = []</span>
                <span class="c1">#count = 0</span>
                <span class="c1">#for node in velemNodes[i]: #for each node in tetrahedron i</span>
                <span class="c1">#    print(node)</span>
                <span class="c1">#    if node in velemNodes[j]: #if each node of the tetrahedron i is in nodelist of tetrahedron j</span>
                <span class="c1">#        count += 1</span>
                <span class="c1">#        shared_nodes.append(node) #append the node that it is in common</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shared_nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span> <span class="c1">#after have done this for all the nodes, if the cound is 3 then calculate the shared area between the tetrahedrons</span>
                    <span class="n">sc0</span> <span class="o">=</span> <span class="n">nodecoords</span><span class="p">[</span><span class="n">node_indices</span><span class="p">[</span><span class="n">shared_nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]],:]</span>
                    <span class="c1">#sc0 = gmsh.model.mesh.getNode(shared_nodes[0])[0] #coordinates of node 0</span>
                    <span class="n">sc1</span> <span class="o">=</span> <span class="n">nodecoords</span><span class="p">[</span><span class="n">node_indices</span><span class="p">[</span><span class="n">shared_nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">]],:]</span>
                    <span class="c1">#sc1 = gmsh.model.mesh.getNode(shared_nodes[1])[0] #coordinates of node 1</span>
                    <span class="n">sc2</span> <span class="o">=</span> <span class="n">nodecoords</span><span class="p">[</span><span class="n">node_indices</span><span class="p">[</span><span class="n">shared_nodes</span><span class="p">[</span><span class="mi">2</span><span class="p">]],:]</span>
                    <span class="c1">#sc2 = gmsh.model.mesh.getNode(shared_nodes[2])[0] #coordinates of node 2</span>
                    <span class="n">shared_area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">sc2</span><span class="o">-</span><span class="n">sc0</span><span class="p">,</span><span class="n">sc1</span><span class="o">-</span><span class="n">sc0</span><span class="p">))</span><span class="o">/</span><span class="mi">2</span> <span class="c1">#compute shared area</span>
                    <span class="n">shared_distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">cell_center_i</span> <span class="o">-</span> <span class="n">cell_center</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                        <span class="c1">#sqrt((abs(cell_center_i[0] - cell_center_j[0]))**2 + (abs(cell_center_i[1] - cell_center_j[1]))**2 + (abs(cell_center_i[2] - cell_center_j[2]))**2) #distance between volume elements</span>
                    <span class="n">interior_tet</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">shared_area</span><span class="o">/</span><span class="n">shared_distance</span> <span class="c1">#division between shared area and shared distance</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">shared_area</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">interior_tet</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">shared_area</span>
    
    <span class="n">interior_tet_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">interior_tet</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="c1">#sum of interior_tet per columns (so per i element)</span>
    
    <span class="k">return</span> <span class="n">interior_tet</span><span class="p">,</span> <span class="n">interior_tet_sum</span></div>


<span class="c1">#%%</span>
<span class="c1">###############################################################################</span>
<span class="c1">#CALCULATION OF </span>
<span class="c1">###############################################################################</span>
<span class="c1"># Calculation surface areas</span>
<div class="viewcode-block" id="surface_absorption_fun">
<a class="viewcode-back" href="../../../acousticDE/FVMfunctions.html#acousticDE.FiniteVolumeMethod.FVMfunctions.surface_absorption_fun">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">surface_absorption_fun</span><span class="p">(</span><span class="n">vGroupsNames</span><span class="p">,</span><span class="n">df_abs</span><span class="p">,</span><span class="n">nBands</span><span class="p">,</span><span class="n">th</span><span class="p">,</span><span class="n">c0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Assign the absoprtion term to each triangle boundary face depending on the surface material and the frequency</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        vGroupsNames : list </span>
<span class="sd">            List of the names of the materials in the msh file (the material name are the same as the one assigned in the SketchUp file)</span>
<span class="sd">        df_abs : Dataframe </span>
<span class="sd">            Absoprtion coefficient for each material assigned</span>
<span class="sd">        nBands : int </span>
<span class="sd">            Number of frequency bands</span>
<span class="sd">        th : int</span>
<span class="sd">            Option for the absorption term; Sabine (th=1), Eyring (th=2) and modified by Xiang (th=3)</span>
<span class="sd">        c0 : int </span>
<span class="sd">            Speed of sound </span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">        ValueError: If there are not values in the csv file, it will raise it as an error.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        surface_absorption : list of tuples</span>
<span class="sd">            List of absorption term for each surface and for each frequency</span>
<span class="sd">        triangle_face_absorption : list of arrays </span>
<span class="sd">            Absorption term value for each triangle face at the boundary</span>
<span class="sd">        absorption_coefficient_dict : dict</span>
<span class="sd">            Dictionary initialization of absorption coefficients per each surface and per each frequency </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#Initialize a list to store surface tags and their absorption coefficients</span>
    <span class="n">surface_absorption</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1">#initialization absorption term (alpha*surfaceofwall) for each wall of the room</span>
    <span class="n">triangle_face_absorption</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1">#initialization absorption term for each triangle face at the boundary and per each wall</span>
    <span class="n">absorption_coefficient_dict</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">vGroupsNames</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">group</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">name_group</span> <span class="o">=</span> <span class="n">group</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">row</span> <span class="o">=</span> <span class="n">df_abs</span><span class="p">[</span><span class="n">df_abs</span><span class="p">[</span><span class="s2">&quot;Material&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">name_group</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">row</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No absorption data found for surface: </span><span class="si">{</span><span class="n">name_group</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">abscoeff</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="c1">#input(f&quot;Enter absorption coefficient for frequency {fc_low} to {fc_high} for {name_abs_coeff}:&quot;) </span>
        <span class="n">absorption_coefficient_dict</span><span class="p">,</span> <span class="n">surface_absorption</span> <span class="o">=</span> <span class="n">surface_materials</span> <span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">abscoeff</span><span class="p">,</span> <span class="n">surface_absorption</span><span class="p">,</span> <span class="n">absorption_coefficient_dict</span><span class="p">,</span><span class="n">nBands</span><span class="p">,</span><span class="n">th</span><span class="p">,</span><span class="n">c0</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">entity</span><span class="p">,</span> <span class="n">Abs_term</span> <span class="ow">in</span> <span class="n">surface_absorption</span><span class="p">:</span>
        <span class="n">triangle_faces</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">getElementsByType</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">entity</span><span class="p">)</span> <span class="c1">#Get all the triangle faces for the current surface</span>
        <span class="n">triangle_face_absorption</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">Abs_term</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">triangle_faces</span><span class="p">))</span> <span class="c1">#Append the Abs_term value for each triangle face</span>

    <span class="k">return</span> <span class="n">surface_absorption</span><span class="p">,</span> <span class="n">triangle_face_absorption</span><span class="p">,</span> <span class="n">absorption_coefficient_dict</span></div>





<span class="c1">#%%</span>
<span class="c1">###############################################################################</span>
<span class="c1">#CALCULATION OF ENTIRE SURFACE AREA PER MATERIAL</span>
<span class="c1">###############################################################################</span>
<span class="c1"># Calculation surface areas</span>
<div class="viewcode-block" id="surface_area">
<a class="viewcode-back" href="../../../acousticDE/FVMfunctions.html#acousticDE.FiniteVolumeMethod.FVMfunctions.surface_area">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">surface_area</span><span class="p">(</span><span class="n">surface_absorption</span><span class="p">,</span> <span class="n">nodecoords</span><span class="p">,</span> <span class="n">node_indices</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of total surface area for each model surface</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        surface_absorption : list of tuples </span>
<span class="sd">            List of absorption term for each surface and for each frequency</span>
<span class="sd">        nodecoords : array of floats </span>
<span class="sd">            The coordinates of each node in the mesh</span>
<span class="sd">        node_indices :dict </span>
<span class="sd">            Indeces of all the nodes in the mesh</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        surface_areas : dict</span>
<span class="sd">            Surface are for each surface of the model</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">surface_areas</span> <span class="o">=</span> <span class="p">{}</span>   
    <span class="k">for</span> <span class="n">entity</span><span class="p">,</span> <span class="n">Abs_term</span> <span class="ow">in</span> <span class="n">surface_absorption</span><span class="p">:</span>   
        <span class="n">face_nodes_per_entity</span><span class="o">=</span> <span class="n">gmsh</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">getElementFaceNodes</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="n">entity</span><span class="p">)</span>
        <span class="n">surf_area_tot</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">face_nodes_per_entity</span><span class="p">),</span> <span class="mi">3</span><span class="p">):</span> <span class="c1"># per each element basically, goes trhough the nodes of each face 3by3</span>
            <span class="c1">#print(i)</span>
            <span class="n">f</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">face_nodes_per_entity</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]))</span> 
            <span class="n">fc0</span> <span class="o">=</span> <span class="n">nodecoords</span><span class="p">[</span><span class="n">node_indices</span><span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]],:]</span>
            <span class="c1">#fc0 = gmsh.model.mesh.getNode(f[0])[0] #coordinates of vertix 0</span>
            <span class="n">fc1</span> <span class="o">=</span> <span class="n">nodecoords</span><span class="p">[</span><span class="n">node_indices</span><span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]],:]</span>
            <span class="n">fc2</span> <span class="o">=</span> <span class="n">nodecoords</span><span class="p">[</span><span class="n">node_indices</span><span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">]],:]</span>
            <span class="c1">#fc1 = gmsh.model.mesh.getNode(f[1])[0] #coordinates of vertix 1</span>
            <span class="c1">#fc2 = gmsh.model.mesh.getNode(f[2])[0] #coordinates of vertix 2</span>
            <span class="n">face_area</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">fc1</span> <span class="o">-</span> <span class="n">fc0</span><span class="p">,</span> <span class="n">fc2</span> <span class="o">-</span> <span class="n">fc0</span><span class="p">))</span> <span class="c1">#Compute the area using half of the cross product&#39;s magnitude</span>
            <span class="n">surf_area_tot</span> <span class="o">+=</span> <span class="n">face_area</span>
            <span class="n">surface_areas</span><span class="p">[</span><span class="n">entity</span><span class="p">]</span> <span class="o">=</span> <span class="n">surf_area_tot</span>
    <span class="k">return</span> <span class="n">surface_areas</span></div>


<span class="c1">#%%</span>
<span class="c1">###############################################################################</span>
<span class="c1">#CALCULATION OF BOUNDARY ELEMENTS</span>
<span class="c1">###############################################################################</span>
<span class="c1">#FACE AREA &amp; boundary_areas</span>
<div class="viewcode-block" id="boundary_triang">
<a class="viewcode-back" href="../../../acousticDE/FVMfunctions.html#acousticDE.FiniteVolumeMethod.FVMfunctions.boundary_triang">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">boundary_triang</span><span class="p">(</span><span class="n">velemNodes</span><span class="p">,</span> <span class="n">nBands</span><span class="p">,</span> <span class="n">bounNode</span><span class="p">,</span> <span class="n">nodecoords</span><span class="p">,</span> <span class="n">node_indices</span><span class="p">,</span> <span class="n">triangle_face_absorption</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Assign the correct equaivalent area to each surface to each tetrahedra</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        velemNodes : array of int</span>
<span class="sd">            Indeces of all the volumetric nodes per each colume element in the mesh</span>
<span class="sd">        nBands : int </span>
<span class="sd">            Number of frequency bands</span>
<span class="sd">        bounNode : array of int </span>
<span class="sd">            Indeces of all the boundary nodes per each boundary surface in the mesh</span>
<span class="sd">        nodecoords : array of floats</span>
<span class="sd">            The coordinates of each node in the mesh</span>
<span class="sd">        node_indices : dict </span>
<span class="sd">            Indeces of all the nodes in the mesh</span>
<span class="sd">        triangle_face_absorption : list of arrays</span>
<span class="sd">            Absorption term value for each triangle face at the boundary</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        boundary_areas : array of floats </span>
<span class="sd">            Product between the area and the correspondent absorption term for each surface for each tetrahedron</span>
<span class="sd">        total_boundArea : float</span>
<span class="sd">            Total surface area of the room</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">total_boundArea</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># initialization of total surface area of the room</span>
    <span class="n">boundary_areas</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Initialize a list to store boundary_areas values for each tetrahedron</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">itertools</span>
    <span class="n">face_areas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
        <span class="nb">len</span><span class="p">(</span><span class="n">velemNodes</span><span class="p">))</span>  <span class="c1"># Per each tetrahedron, if there is a face that is on the boundary, include the area, otehrwise zero</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">element</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">velemNodes</span><span class="p">):</span>  <span class="c1"># for index and element in the number of tetrahedrons</span>
        <span class="c1"># if idx == 491:</span>
        <span class="n">tetrahedron_boundary_areas</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># initialization tetrahedron face on boundary*its absorption term</span>
        <span class="n">total_tetrahedron_boundary_areas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nBands</span><span class="p">)</span>  <span class="c1"># initialization total tetrahedron face on boundary*its absorption term if there are more than one face in the tetrahedron that is on the boundary</span>
        <span class="c1"># print(idx)</span>
        <span class="n">node_combinations</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="k">for</span> <span class="n">nodes</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">element</span><span class="p">,</span><span class="mi">3</span><span class="p">)]</span>  <span class="c1"># all possible combinations of the nodes of the tetrahedrons (it checks also for the order of the nodes in the same combination)</span>
        <span class="c1"># Check if the nodes are in any order in bounNode</span>
        <span class="n">is_boundary</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># variable to say that at the beginning the face in not on a boundary</span>
        <span class="k">for</span> <span class="n">nodes</span> <span class="ow">in</span> <span class="n">node_combinations</span><span class="p">:</span>  <span class="c1"># for each node in each combination</span>
            <span class="k">for</span> <span class="n">surface_idx</span><span class="p">,</span> <span class="n">surface</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bounNode</span><span class="p">):</span>  <span class="c1"># for index and surface in the number of nodes</span>
                <span class="n">surface_set</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">surface</span><span class="p">))</span>  <span class="c1"># creates a set of the surface nodes</span>
                <span class="n">surface_set_idx</span> <span class="o">=</span> <span class="n">surface_idx</span>
                <span class="n">nodes_set</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">nodes</span><span class="p">))</span>  <span class="c1"># create a set of the node combination of the tetrahedron into consideration</span>
                <span class="c1"># surface_list = list(surface)</span>
                <span class="k">if</span> <span class="n">nodes_set</span> <span class="o">==</span> <span class="n">surface_set</span><span class="p">:</span>  <span class="c1"># if these are equal, it means that the tetrahedron into consideration has a surface in the boundary and therefore is_boundary gets the value of True.</span>
                    <span class="c1"># print(surface_set)</span>
                    <span class="c1"># print(surface_list)</span>
                    <span class="n">is_boundary</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">if</span> <span class="n">is_boundary</span><span class="p">:</span>  <span class="c1"># if the surface is at the boundary, then take the coordinates of each vertix</span>
                        <span class="c1"># Convert the vertices to NumPy arrays for vector operations</span>
                        <span class="n">bc0</span> <span class="o">=</span> <span class="n">nodecoords</span><span class="p">[</span><span class="n">node_indices</span><span class="p">[</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">:]</span>
                        <span class="n">bc1</span> <span class="o">=</span> <span class="n">nodecoords</span><span class="p">[</span><span class="n">node_indices</span><span class="p">[</span><span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="p">:]</span>
                        <span class="n">bc2</span> <span class="o">=</span> <span class="n">nodecoords</span><span class="p">[</span><span class="n">node_indices</span><span class="p">[</span><span class="n">nodes</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span> <span class="p">:]</span>

                        <span class="c1"># bc0 = gmsh.model.mesh.getNode(nodes[0])[0] #coordinates of vertix 0</span>
                        <span class="c1"># bc1 = gmsh.model.mesh.getNode(nodes[1])[0] #coordinates of vertix 1</span>
                        <span class="c1"># bc2 = gmsh.model.mesh.getNode(nodes[2])[0] #coordinates of vertix 2</span>

                        <span class="n">face_area</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">bc1</span> <span class="o">-</span> <span class="n">bc0</span><span class="p">,</span> <span class="n">bc2</span> <span class="o">-</span> <span class="n">bc0</span><span class="p">))</span>  <span class="c1"># Compute the area using half of the cross product&#39;s magnitude</span>
                        <span class="c1"># print(face_area)</span>

                        <span class="n">face_areas</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">face_area</span>  <span class="c1"># area of the surface that is on boundary per each tetrahedron</span>
                        <span class="n">total_boundArea</span> <span class="o">+=</span> <span class="n">face_area</span>  <span class="c1"># add to the total boundary area</span>

                        <span class="k">if</span> <span class="n">face_area</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="c1"># Use the index to access the corresponding absorption area</span>
                            <span class="n">face_absorption_product</span> <span class="o">=</span> <span class="n">face_area</span> <span class="o">*</span> <span class="n">triangle_face_absorption</span><span class="p">[</span><span class="n">surface_set_idx</span><span class="p">]</span>  <span class="c1"># calculate the product between the area*the correspondent absorption term</span>
                            <span class="c1"># print(face_absorption_product)</span>

                            <span class="n">tetrahedron_boundary_areas</span> <span class="o">+=</span> <span class="n">face_absorption_product</span>  <span class="c1"># add the calculation to the tetrahedron correspondent</span>

                            <span class="n">total_tetrahedron_boundary_areas</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">tetrahedron_boundary_areas</span>  <span class="c1"># if there are multiple surfaces on the boundary per each tetrahedron, then add also the second and the third one</span>

        <span class="n">boundary_areas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="n">total_tetrahedron_boundary_areas</span><span class="p">))</span>  <span class="c1"># Append the total boundary_areas for the tetrahedron to the list</span>
    <span class="c1"># print(total_tetrahedron_boundary_areas)</span>
    <span class="n">boundary_areas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">boundary_areas</span><span class="p">)</span>
    <span class="n">boundary_areas</span> <span class="o">=</span> <span class="n">boundary_areas</span><span class="o">.</span><span class="n">T</span>
    <span class="k">return</span> <span class="n">boundary_areas</span><span class="p">,</span> <span class="n">total_boundArea</span></div>



<span class="c1">#%%</span>
<span class="c1">###############################################################################</span>
<span class="c1">#CALCULATION OF EQUIVALENT ABSORPTION AREA</span>
<span class="c1">###############################################################################</span>
<div class="viewcode-block" id="equiv_absorp_area">
<a class="viewcode-back" href="../../../acousticDE/FVMfunctions.html#acousticDE.FiniteVolumeMethod.FVMfunctions.equiv_absorp_area">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">equiv_absorp_area</span><span class="p">(</span><span class="n">cell_volume</span><span class="p">,</span> <span class="n">total_boundArea</span><span class="p">,</span> <span class="n">surface_areas_in</span><span class="p">,</span> <span class="n">absorption_coefficient_dict</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of the eqauivalent absorption area</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        cell_volume : array of floats</span>
<span class="sd">            The volume of each element cell</span>
<span class="sd">        total_boundArea : float </span>
<span class="sd">            Total surface area of the room</span>
<span class="sd">        surface_areas_in : dict</span>
<span class="sd">            Surface are for each surface of the model</span>
<span class="sd">        absorption_coefficient_dict : dict </span>
<span class="sd">            Dictionary of absorption coefficients per each surface and per each frequency</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        V : float</span>
<span class="sd">            Volume of the room</span>
<span class="sd">        S : float</span>
<span class="sd">            Total surface are of the room</span>
<span class="sd">        Eq_A : array of floats</span>
<span class="sd">            Equivalent absorption area</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">V</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">cell_volume</span><span class="p">)</span> <span class="c1">#volume of the room</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">total_boundArea</span> <span class="c1">#total surface area of the room</span>
    
    <span class="n">sum_alpha_average</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">Eq_A</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1">#Absorption parameters for room</span>
    <span class="k">for</span> <span class="n">entity</span> <span class="ow">in</span> <span class="n">surface_areas_in</span><span class="p">:</span>
        <span class="c1">#print(entity)</span>
        <span class="n">sum_alpha_average</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">absorption_coefficient_dict</span><span class="p">[</span><span class="n">entity</span><span class="p">],</span><span class="n">surface_areas_in</span><span class="p">[</span><span class="n">entity</span><span class="p">])</span>
        <span class="n">Eq_A</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">absorption_coefficient_dict</span><span class="p">[</span><span class="n">entity</span><span class="p">],</span><span class="n">surface_areas_in</span><span class="p">[</span><span class="n">entity</span><span class="p">])</span>
    <span class="c1">#alpha_average = sum_alpha_average/S #average absorption</span>
    
    <span class="k">return</span> <span class="n">V</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">Eq_A</span></div>



<div class="viewcode-block" id="calculation_sourceon_time">
<a class="viewcode-back" href="../../../acousticDE/FVMfunctions.html#acousticDE.FiniteVolumeMethod.FVMfunctions.calculation_sourceon_time">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">calculation_sourceon_time</span><span class="p">(</span><span class="n">nBands</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">Eq_A</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of the time the sources stays on</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        nBands : int</span>
<span class="sd">            Number of frequency bands</span>
<span class="sd">        V : float</span>
<span class="sd">            Volume of the room</span>
<span class="sd">        Eq_A : array of floats</span>
<span class="sd">            Equivalent absorption</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        sourceon_time : float</span>
<span class="sd">            Time that the source stays on</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">RT_Sabine_band</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">iBand</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nBands</span><span class="p">):</span>
        <span class="c1">#freq = center_freq[iBand]</span>
        <span class="n">RT_Sabine</span> <span class="o">=</span> <span class="mf">0.16</span><span class="o">*</span><span class="n">V</span><span class="o">/</span><span class="n">Eq_A</span><span class="p">[</span><span class="n">iBand</span><span class="p">]</span>
        <span class="n">RT_Sabine_band</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">RT_Sabine</span><span class="p">)</span>
    
    <span class="n">sourceon_time</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">RT_Sabine_band</span><span class="p">),</span><span class="mi">1</span><span class="p">)</span><span class="c1">#time that the source is ON before interrupting [s]</span>

    <span class="k">return</span> <span class="n">sourceon_time</span></div>



<span class="c1">#%%</span>
<span class="c1">###############################################################################</span>
<span class="c1">#CALCULATION OF SABINE RT, TOTAL RECORDING TIME AND SOURCE ON TIME</span>
<span class="c1">###############################################################################</span>

<div class="viewcode-block" id="calculation_rec_time">
<a class="viewcode-back" href="../../../acousticDE/FVMfunctions.html#acousticDE.FiniteVolumeMethod.FVMfunctions.calculation_rec_time">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">calculation_rec_time</span><span class="p">(</span><span class="n">sourceon_time</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">edt</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">ir_length</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of the simulation time run</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        sourceon_time : float</span>
<span class="sd">            Time that the source stays on</span>
<span class="sd">        dt : float</span>
<span class="sd">            Time step</span>
<span class="sd">        edt : int, optional</span>
<span class="sd">            Early decay time. Defaults to -1.</span>
<span class="sd">        ir_length : int, optional</span>
<span class="sd">            Impulse response length. Defaults to -1.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        recording_time : float</span>
<span class="sd">            Length of the simulaton run</span>
<span class="sd">        t : array of floats</span>
<span class="sd">            Time array of time steps</span>
<span class="sd">        recording_steps : int</span>
<span class="sd">            Number of time steps</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">edt</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;</span> <span class="n">ir_length</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">recording_time</span> <span class="o">=</span> <span class="n">sourceon_time</span> <span class="o">*</span> <span class="mi">2</span>
    <span class="k">elif</span> <span class="n">edt</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">recording_time</span> <span class="o">=</span> <span class="n">sourceon_time</span> <span class="o">+</span> <span class="p">(</span><span class="n">sourceon_time</span> <span class="o">/</span> <span class="mi">60</span> <span class="o">*</span> <span class="n">edt</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">ir_length</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">recording_time</span> <span class="o">=</span> <span class="n">sourceon_time</span> <span class="o">+</span> <span class="n">ir_length</span>

    <span class="c1"># Time resolution</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">recording_time</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>  <span class="c1"># mesh point in time</span>
    <span class="n">recording_steps</span> <span class="o">=</span> <span class="n">ceil</span><span class="p">(</span><span class="n">recording_time</span> <span class="o">/</span> <span class="n">dt</span><span class="p">)</span>  <span class="c1"># number of time steps to consider in the calculation</span>
        
    <span class="k">return</span> <span class="n">recording_time</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">recording_steps</span></div>


<span class="c1">#%%</span>
<span class="c1">###############################################################################</span>
<span class="c1">#CALCULATION OF DIFFUSION PARAMETERS</span>
<span class="c1">###############################################################################</span>
<span class="c1">#Diffusion parameters</span>
<div class="viewcode-block" id="diffusion_coeff">
<a class="viewcode-back" href="../../../acousticDE/FVMfunctions.html#acousticDE.FiniteVolumeMethod.FVMfunctions.diffusion_coeff">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">diffusion_coeff</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">c0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of the theoretical diffusion coefficient</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        V : float</span>
<span class="sd">            Volume of the room</span>
<span class="sd">        S : float</span>
<span class="sd">            Total surface are of the room</span>
<span class="sd">        c0 : int</span>
<span class="sd">            Speed of sound </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        Dx : float </span>
<span class="sd">            Diffusion coefficient in the x direction (equal to the theoretical diffusion coefficient)</span>
<span class="sd">        Dy : float </span>
<span class="sd">            Diffusion coefficient in the y direction (equal to the theoretical diffusion coefficient)</span>
<span class="sd">        Dz : float</span>
<span class="sd">            Diffusion coefficient in the z direction (equal to the theoretical diffusion coefficient)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mean_free_path</span> <span class="o">=</span> <span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">V</span><span class="p">)</span><span class="o">/</span><span class="n">S</span> <span class="c1">#mean free path for 3D</span>
    <span class="c1">#mean_free_time = mean_free_path/c0 #mean free time for 3D</span>
    <span class="c1">#mean_free_time_step = int(mean_free_time/dt)</span>
    <span class="n">Dx</span> <span class="o">=</span> <span class="p">(</span><span class="n">mean_free_path</span><span class="o">*</span><span class="n">c0</span><span class="p">)</span><span class="o">/</span><span class="mi">3</span> <span class="c1">#diffusion coefficient for proportionate rooms x direction</span>
    <span class="n">Dy</span> <span class="o">=</span> <span class="p">(</span><span class="n">mean_free_path</span><span class="o">*</span><span class="n">c0</span><span class="p">)</span><span class="o">/</span><span class="mi">3</span> <span class="c1">#diffusion coefficient for proportionate rooms y direction</span>
    <span class="n">Dz</span> <span class="o">=</span> <span class="p">(</span><span class="n">mean_free_path</span><span class="o">*</span><span class="n">c0</span><span class="p">)</span><span class="o">/</span><span class="mi">3</span> <span class="c1">#diffusion coefficient for proportionate rooms z direction</span>
    <span class="k">return</span> <span class="n">Dx</span><span class="p">,</span> <span class="n">Dy</span><span class="p">,</span> <span class="n">Dz</span></div>


<span class="c1">#%%</span>
<span class="c1">###############################################################################</span>
<span class="c1">#CALCULATION OF SOURCE &amp; RECEIVER DISTANCE</span>
<span class="c1">###############################################################################</span>

<div class="viewcode-block" id="distance_source_receiver">
<a class="viewcode-back" href="../../../acousticDE/FVMfunctions.html#acousticDE.FiniteVolumeMethod.FVMfunctions.distance_source_receiver">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">distance_source_receiver</span><span class="p">(</span><span class="n">coord_rec</span><span class="p">,</span> <span class="n">coord_source</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of the distance between source and receiver positions</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        coord_rec : list </span>
<span class="sd">            Coordinates of the receiver position</span>
<span class="sd">        coord_source : list</span>
<span class="sd">            Coordinates of the source position</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        dist_sr : float</span>
<span class="sd">            Distance between source and receiver position</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#distance between source and receiver</span>
    <span class="n">dist_sr</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="nb">abs</span><span class="p">(</span><span class="n">coord_rec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">coord_source</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">coord_rec</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">coord_source</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">coord_rec</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">coord_source</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="c1">#distance between source and receiver</span>
    <span class="k">return</span> <span class="n">dist_sr</span></div>


<span class="c1">#%%</span>
<span class="c1">###############################################################################</span>
<span class="c1">#SOURCE INTERPOLATION</span>
<span class="c1">###############################################################################</span>
<div class="viewcode-block" id="source_interp">
<a class="viewcode-back" href="../../../acousticDE/FVMfunctions.html#acousticDE.FiniteVolumeMethod.FVMfunctions.source_interp">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">source_interp</span><span class="p">(</span><span class="n">cell_center</span><span class="p">,</span> <span class="n">coord_source</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Interpolation of the source position</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        cell_center : array of floats</span>
<span class="sd">            The coordinates of the center of the cell element per each element</span>
<span class="sd">        coord_source : list</span>
<span class="sd">            Coordinates of the source position</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        cl_tet_s_keys : Dict keys</span>
<span class="sd">            Clossest tetrahedrons indeces to the source</span>
<span class="sd">        total_weights_s : dict</span>
<span class="sd">            Weights for each 4 closest points to the source position for interpolation</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1">#SOURCE INTERPOLATION CALCULATED WITHIN 4 CENTRE CELL SELECTED (TETRAHEDRON)</span>
    <span class="c1">#Position of source is the centre of a cell so the minimum distance with the centre of a cell has been calculated to understand which cell is the closest</span>
    <span class="n">dist_source_cc_list</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1">#initialise the list for all the distances between each cell centre and the source</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cell_center</span><span class="p">)):</span> <span class="c1">#for each tetra</span>
        <span class="n">dist_source_cc</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">cell_center</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">coord_source</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="c1">#calculate the distance between its centre cell and the source coordinate</span>
        <span class="n">dist_source_cc_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dist_source_cc</span><span class="p">)</span> <span class="c1">#append the distance in a list</span>
    <span class="c1">#source_idx = np.argmin(dist_source_cc_list) #take the minimum distance index; this is where the source will be positioned</span>
    
    <span class="n">dist_source_cc_list_sorted</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">dist_source_cc_list</span><span class="p">)</span> <span class="c1">#sorted from the minimum to the maximum distance</span>
    <span class="n">selected_source_cc_list</span> <span class="o">=</span> <span class="n">dist_source_cc_list_sorted</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span> <span class="c1">#take only the first four element of the sorted list (take the first 4 cell centres closest to the source)</span>
    
    <span class="n">dist_source_cc_list_sorted_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">dist_source_cc_list</span><span class="p">)[:</span><span class="mi">4</span><span class="p">]</span> <span class="c1">#takes the indeces of the minimum distances</span>
    <span class="c1">#selected_source_cc_list_indices = dist_source_cc_list_sorted_indices[:4] #does exactly the same as the previous line</span>
    
    <span class="c1">#cl_tet_s stands for cl=closest, tet=tetrahedron, s=to the source</span>
    <span class="n">cl_tet_s</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1">#initialise dictionary for closest tetrahedrons to the source</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dist_source_cc_list_sorted_indices</span><span class="p">)):</span> <span class="c1">#for each of the 4 tetra closest to the source</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">selected_source_cc_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="c1">#take its index</span>
        <span class="n">cl_tet_s</span><span class="p">[</span><span class="n">dist_source_cc_list_sorted_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">idx</span> <span class="c1">#put it in a dictionary</span>
    
    <span class="n">total_weights_s</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1">#initialise weights for each tetrahedron around the actual source position</span>
    <span class="n">sum_weights_s</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1">#Vs = 0</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">dist</span> <span class="ow">in</span> <span class="n">cl_tet_s</span><span class="o">.</span><span class="n">items</span><span class="p">():</span> <span class="c1">#for each key and value in the dictionary (so for each closest tetrahedron to the source)</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="mf">1.0</span> <span class="p">,</span> <span class="n">dist</span><span class="p">)</span>  <span class="c1">#calculate the inverse distance weights, so closer to the point means higher weight</span>
        <span class="c1">#print(weights)</span>
        <span class="n">sum_weights_s</span> <span class="o">+=</span> <span class="n">weights</span>
        <span class="c1">#weights /= np.sum(weights)  # Normalize weights to sum to 1</span>
        <span class="n">total_weights_s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">weights</span> <span class="c1">#put the wweigths (values) to the correspondent closest tetrahedron (keys)</span>
        <span class="c1">#Vs += cell_volume[i] #volume of the source calculated summing the volumes of all the tetrahedrons involved</span>
    
    <span class="c1">#total_weights_s_values = total_weights_s.values()</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">weight</span> <span class="ow">in</span> <span class="n">total_weights_s</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">total_weights_s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">weight</span><span class="o">/</span><span class="n">sum_weights_s</span> <span class="k">if</span> <span class="n">sum_weights_s</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
    
    <span class="n">cl_tet_s_keys</span> <span class="o">=</span> <span class="n">cl_tet_s</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="c1">#take only the keys of the cl_tet_s dictionary (so basically the indexes of the tetrahedrons)</span>

    <span class="k">return</span> <span class="n">cl_tet_s_keys</span><span class="p">,</span> <span class="n">total_weights_s</span></div>


<span class="c1">#%%</span>
<span class="c1">###############################################################################</span>
<span class="c1">#CALCULATION OF SOURCE VOLUME</span>
<span class="c1">###############################################################################</span>

<div class="viewcode-block" id="source_volume">
<a class="viewcode-back" href="../../../acousticDE/FVMfunctions.html#acousticDE.FiniteVolumeMethod.FVMfunctions.source_volume">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">source_volume</span><span class="p">(</span><span class="n">velemNodes</span><span class="p">,</span> <span class="n">nodecoords</span><span class="p">,</span> <span class="n">coord_source</span><span class="p">,</span> <span class="n">cell_volume</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of the volume of the source</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        velemNodes : array of int</span>
<span class="sd">            Indeces of all the volumetric nodes per each colume element in the mesh</span>
<span class="sd">        nodecoords : array of floats</span>
<span class="sd">            The coordinates of each node in the mesh</span>
<span class="sd">        coord_source : list</span>
<span class="sd">            Coordinates of the source position</span>
<span class="sd">        cell_volume : array of floats</span>
<span class="sd">            The volume of each element cell</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        Vs : float</span>
<span class="sd">            Volume of the source</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#To make sure that the source is in the correct tetrahedron position</span>
    <span class="n">node_ids</span> <span class="o">=</span> <span class="n">velemNodes</span><span class="o">.</span><span class="n">T</span>
    <span class="n">ori</span><span class="o">=</span><span class="n">nodecoords</span><span class="p">[</span><span class="n">node_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span><span class="o">-</span><span class="mi">1</span><span class="p">,:]</span>
    <span class="c1">#ori = nodecoords[node_indices[node_ids[:,0],:]]</span>
    <span class="n">v_tet_s1</span><span class="o">=</span><span class="n">nodecoords</span><span class="p">[</span><span class="n">node_ids</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span><span class="o">-</span><span class="mi">1</span><span class="p">,:]</span><span class="o">-</span><span class="n">ori</span>
    <span class="n">v_tet_s2</span><span class="o">=</span><span class="n">nodecoords</span><span class="p">[</span><span class="n">node_ids</span><span class="p">[</span><span class="mi">2</span><span class="p">,:]</span><span class="o">-</span><span class="mi">1</span><span class="p">,:]</span><span class="o">-</span><span class="n">ori</span>
    <span class="n">v_tet_s3</span><span class="o">=</span><span class="n">nodecoords</span><span class="p">[</span><span class="n">node_ids</span><span class="p">[</span><span class="mi">3</span><span class="p">,:]</span><span class="o">-</span><span class="mi">1</span><span class="p">,:]</span><span class="o">-</span><span class="n">ori</span>
    <span class="n">n_tet</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">node_ids</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    <span class="n">v1s</span> <span class="o">=</span> <span class="n">v_tet_s1</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">n_tet</span><span class="p">))</span>
    <span class="n">v2s</span> <span class="o">=</span> <span class="n">v_tet_s2</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">n_tet</span><span class="p">))</span>
    <span class="n">v3s</span> <span class="o">=</span> <span class="n">v_tet_s3</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">n_tet</span><span class="p">))</span>
    <span class="n">mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">v1s</span><span class="p">,</span><span class="n">v2s</span><span class="p">,</span><span class="n">v3s</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">inv_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">mat</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="c1">#if coord_source.size==3:  # to make rec has a dimension of (N_rec,3)</span>
    <span class="c1">#    rec=rec.reshape((1,3))</span>
    <span class="n">coord_source_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coord_source</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">coord_source_array</span><span class="o">.</span><span class="n">size</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>  <span class="c1"># to make rec has a dimension of (N_rec,3)</span>
        <span class="n">coord_source_array</span><span class="o">=</span><span class="n">coord_source_array</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
    <span class="n">N_sou</span><span class="o">=</span><span class="n">coord_source_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">orir</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">ori</span><span class="p">[:,:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">N_sou</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">newp</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;imk,kmj-&gt;kij&#39;</span><span class="p">,</span><span class="n">inv_mat</span><span class="p">,</span><span class="n">coord_source_array</span><span class="o">.</span><span class="n">T</span><span class="o">-</span><span class="n">orir</span><span class="p">)</span>
    <span class="n">val</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">newp</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">newp</span> <span class="o">&lt;=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">newp</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">&lt;=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">id_tet</span><span class="p">,</span> <span class="n">id_p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
    <span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N_sou</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">id_tet</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="c1"># Sentinel value</span>
    <span class="n">res</span><span class="p">[</span><span class="n">id_p</span><span class="p">]</span><span class="o">=</span><span class="n">id_tet</span>
        
    <span class="c1">#VOLUME ORIGINAL</span>
    <span class="n">Vs</span> <span class="o">=</span> <span class="n">cell_volume</span><span class="p">[</span><span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="c1">#volume of the source = to volume of cell where the source is </span>
    <span class="c1"># Vs = 1</span>
    
    <span class="k">return</span> <span class="n">Vs</span></div>


<span class="c1">#%%</span>
<span class="c1">###############################################################################</span>
<span class="c1">#INITIAL CONDITIONS</span>
<span class="c1">###############################################################################</span>
<span class="c1">#Initial condition - Source Info (interrupted method)</span>
<div class="viewcode-block" id="initial_cond">
<a class="viewcode-back" href="../../../acousticDE/FVMfunctions.html#acousticDE.FiniteVolumeMethod.FVMfunctions.initial_cond">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">initial_cond</span><span class="p">(</span><span class="n">Ws</span><span class="p">,</span> <span class="n">Vs</span><span class="p">,</span> <span class="n">sourceon_time</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">recording_steps</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Definition of initial conditions</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        Ws : float</span>
<span class="sd">            Power of the source</span>
<span class="sd">        Vs : float</span>
<span class="sd">            Volume of the source</span>
<span class="sd">        sourceon_time : float</span>
<span class="sd">            Time that the source stays on</span>
<span class="sd">        dt : float</span>
<span class="sd">            Time step</span>
<span class="sd">        recording_steps : int</span>
<span class="sd">            Number of time steps</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        source1 : array of floats</span>
<span class="sd">            Energy density of source number 1 at each time step position</span>
<span class="sd">        sourceon_steps : int</span>
<span class="sd">            Number of time steps while the source is on</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">w1</span><span class="o">=</span><span class="n">Ws</span><span class="o">/</span><span class="n">Vs</span> <span class="c1">#w1 = round(Ws/Vs,4) #power density of the source [Watts/(m^3))]</span>
    <span class="n">sourceon_steps</span> <span class="o">=</span> <span class="n">ceil</span><span class="p">(</span><span class="n">sourceon_time</span><span class="o">/</span><span class="n">dt</span><span class="p">)</span> <span class="c1">#time steps at which the source is calculated/considered in the calculation</span>
    <span class="n">s1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">w1</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">sourceon_steps</span><span class="p">))</span> <span class="c1">#energy density of source number 1 at each time step position</span>
    <span class="n">source1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">recording_steps</span><span class="o">-</span><span class="n">sourceon_steps</span><span class="p">))</span> <span class="c1">#This would be equal to s1 if and only if recoding_steps = sourceon_steps</span>
    <span class="k">return</span> <span class="n">source1</span><span class="p">,</span> <span class="n">sourceon_steps</span></div>


<span class="c1">#%%</span>
<span class="c1">###############################################################################</span>
<span class="c1">#DEFINITION OF SOURCE MATRIX</span>
<span class="c1">###############################################################################</span>
<div class="viewcode-block" id="source_matrix">
<a class="viewcode-back" href="../../../acousticDE/FVMfunctions.html#acousticDE.FiniteVolumeMethod.FVMfunctions.source_matrix">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">source_matrix</span><span class="p">(</span><span class="n">voluEl</span><span class="p">,</span><span class="n">cl_tet_s_keys</span><span class="p">,</span> <span class="n">source1</span><span class="p">,</span> <span class="n">total_weights_s</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of the source matrix</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        voluEl : array of int</span>
<span class="sd">            Indeces of all the bolume elements (tetrahedra) in the mesh</span>
<span class="sd">        cl_tet_s_keys : Dict keys</span>
<span class="sd">            Clossest tetrahedrons indeces to the source</span>
<span class="sd">        source1 : array of floats</span>
<span class="sd">            Energy density of source number 1 at each time step position</span>
<span class="sd">        total_weights_s : dict</span>
<span class="sd">            Weights for each 4 closest points to the source position for interpolation</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        s : array of floats</span>
<span class="sd">            Matrix of tretrahedron central points inserting source energy</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">#INTERPOLATION WITH CELL CENTRES - SOURCE MATRIX</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">voluEl</span><span class="p">)))</span> <span class="c1">#matrix of zeros for source</span>
    <span class="k">for</span> <span class="n">tet_s</span> <span class="ow">in</span> <span class="n">cl_tet_s_keys</span><span class="p">:</span>
        <span class="n">s</span><span class="p">[</span><span class="n">tet_s</span><span class="p">]</span> <span class="o">=</span> <span class="n">source1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span><span class="n">total_weights_s</span><span class="p">[</span><span class="n">tet_s</span><span class="p">]</span>
    
    <span class="k">return</span> <span class="n">s</span></div>


<span class="c1">#%%</span>
<span class="c1">###############################################################################</span>
<span class="c1">#RECEIVER INTERPOLATION</span>
<span class="c1">###############################################################################</span>
<div class="viewcode-block" id="receiver_interp">
<a class="viewcode-back" href="../../../acousticDE/FVMfunctions.html#acousticDE.FiniteVolumeMethod.FVMfunctions.receiver_interp">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">receiver_interp</span><span class="p">(</span><span class="n">cell_center</span><span class="p">,</span> <span class="n">coord_rec</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Interpolation of the receiver position</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        cell_center : array of floats</span>
<span class="sd">            The coordinates of the center of the cell element per each element</span>
<span class="sd">        coord_rec : list</span>
<span class="sd">            Coordinates of the receiver position</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        cl_tet_r_keys : dict keys</span>
<span class="sd">            Closest tetrahedrons indeces to the receiver</span>
<span class="sd">        total_weights_r : dict</span>
<span class="sd">            Weights for each 4 closest points to the receiver position for interpolation</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1">#RECEIVER INTERPOLATION CALCULATED WITHIN 4 CENTRE CELL SELECTED (TETRAHEDRON)</span>
    <span class="c1">#Position of receiver is the centre of a cell so the minimum distance with the centre of a cell has been calculated to understand which cell is the closest</span>
    <span class="n">dist_rec_cc_list</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1">#initialise the list for all the distances between each cell centre and the source</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cell_center</span><span class="p">)):</span> <span class="c1">#for each tetra</span>
        <span class="n">dist_rec_cc</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">cell_center</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">coord_rec</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="c1">#calculate the distance between its centre cell and the source coordinate</span>
        <span class="n">dist_rec_cc_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dist_rec_cc</span><span class="p">)</span> <span class="c1">#append the distance in a list</span>
    <span class="c1">#rec_idx = np.argmin(dist_rec_cc_list) #take the minimum distance index; this is where the source will be positioned</span>
    
    <span class="n">dist_rec_cc_list_sorted</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">dist_rec_cc_list</span><span class="p">)</span> <span class="c1">#sorted from the minimum to the maximum distance</span>
    <span class="n">selected_rec_cc_list</span> <span class="o">=</span> <span class="n">dist_rec_cc_list_sorted</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span> <span class="c1">#take only the first four element of the sorted list (take the first 4 cell centres closest to the source)</span>
    
    <span class="n">dist_rec_cc_list_sorted_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">dist_rec_cc_list</span><span class="p">)[:</span><span class="mi">4</span><span class="p">]</span> <span class="c1">#takes the indeces of the minimum distances</span>
    <span class="c1">#selected_rec_cc_list_indices = dist_rec_cc_list_sorted_indices[:4] #does exactly the same as the previous line</span>
    
    <span class="c1">#cl_tet_s stands for cl=closest, tet=tetrahedron, s=to the source</span>
    <span class="n">cl_tet_r</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1">#initialise dictionary for closest tetrahedrons to the source</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dist_rec_cc_list_sorted_indices</span><span class="p">)):</span> <span class="c1">#for each of the 4 tetra closest to the source</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">selected_rec_cc_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="c1">#take its index</span>
        <span class="n">cl_tet_r</span><span class="p">[</span><span class="n">dist_rec_cc_list_sorted_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">idx</span> <span class="c1">#put it in a dictionary</span>
    
    <span class="n">total_weights_r</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1">#initialise weights for each tetrahedron around the actual source position</span>
    <span class="n">sum_weights_r</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1">#Vs = 0</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">dist</span> <span class="ow">in</span> <span class="n">cl_tet_r</span><span class="o">.</span><span class="n">items</span><span class="p">():</span> <span class="c1">#for each key and value in the dictionary (so for each closest tetrahedron to the source)</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="mf">1.0</span> <span class="p">,</span> <span class="n">dist</span><span class="p">)</span>  <span class="c1">#calculate the inverse distance weights, so closer to the point means higher weight</span>
        <span class="c1">#print(weights)</span>
        <span class="n">sum_weights_r</span> <span class="o">+=</span> <span class="n">weights</span>
        <span class="c1">#weights /= np.sum(weights)  # Normalize weights to sum to 1</span>
        <span class="n">total_weights_r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">weights</span> <span class="c1">#put the wweigths (values) to the correspondent closest tetrahedron (keys)</span>
        <span class="c1">#Vs += cell_volume[i] #volume of the source calculated summing the volumes of all the tetrahedrons involved</span>
    
    <span class="c1">#total_weights_s_values = total_weights_s.values()</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">weight</span> <span class="ow">in</span> <span class="n">total_weights_r</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">total_weights_r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">weight</span><span class="o">/</span><span class="n">sum_weights_r</span> <span class="k">if</span> <span class="n">sum_weights_r</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
    
    <span class="n">cl_tet_r_keys</span> <span class="o">=</span> <span class="n">cl_tet_r</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="c1">#take only the keys of the cl_tet_s dictionary (so basically the indexes of the tetrahedrons)</span>
    
    <span class="k">return</span> <span class="n">cl_tet_r_keys</span><span class="p">,</span> <span class="n">total_weights_r</span></div>


<span class="c1">#%%</span>
<span class="c1">###############################################################################</span>
<span class="c1">#CALCULATION OF LENGTH, WIDTH AND HEIGHT OF ROOM</span>
<span class="c1">###############################################################################</span>

<div class="viewcode-block" id="room_dimensions">
<a class="viewcode-back" href="../../../acousticDE/FVMfunctions.html#acousticDE.FiniteVolumeMethod.FVMfunctions.room_dimensions">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">room_dimensions</span><span class="p">(</span><span class="n">nodecoords</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of the room dimensions</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        nodecoords : array of floats</span>
<span class="sd">            The coordinates of each node in the mesh</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        room_length : float</span>
<span class="sd">            Length of the room</span>
<span class="sd">        room_width : float</span>
<span class="sd">            Width of the room</span>
<span class="sd">        room_height : float</span>
<span class="sd">            Height of the room</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#Extract x-coordinates of all nodes LENGTH</span>
    <span class="n">x_coordinates</span> <span class="o">=</span> <span class="n">nodecoords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="c1">#Find the minimum and maximum x-coordinates to determine the length of the room</span>
    <span class="n">min_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x_coordinates</span><span class="p">)</span>
    <span class="n">max_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x_coordinates</span><span class="p">)</span>
    <span class="c1">#Calculate the length of the room</span>
    <span class="n">room_length</span> <span class="o">=</span> <span class="n">max_x</span> <span class="o">-</span> <span class="n">min_x</span>

    <span class="c1">#Extract y-coordinates of all nodes WIDTH</span>
    <span class="n">y_coordinates</span> <span class="o">=</span> <span class="n">nodecoords</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="c1">#Find the minimum and maximum x-coordinates to determine the width of the room</span>
    <span class="n">min_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">y_coordinates</span><span class="p">)</span>
    <span class="n">max_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">y_coordinates</span><span class="p">)</span>
    <span class="c1">#Calculate the width of the room</span>
    <span class="n">room_width</span> <span class="o">=</span> <span class="n">max_y</span> <span class="o">-</span> <span class="n">min_y</span>
    
    <span class="c1">#Extract y-coordinates of all nodes HEIGHT</span>
    <span class="n">z_coordinates</span> <span class="o">=</span> <span class="n">nodecoords</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span>
    <span class="c1">#Find the minimum and maximum x-coordinates to determine the width of the room</span>
    <span class="n">min_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">z_coordinates</span><span class="p">)</span>
    <span class="n">max_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">z_coordinates</span><span class="p">)</span>
    <span class="c1">#Calculate the height of the room</span>
    <span class="n">room_height</span> <span class="o">=</span> <span class="n">max_z</span> <span class="o">-</span> <span class="n">min_z</span>
    
    <span class="k">return</span> <span class="n">room_length</span><span class="p">,</span> <span class="n">room_width</span><span class="p">,</span> <span class="n">room_height</span></div>

    
<span class="c1">#%%</span>
<span class="c1">###############################################################################</span>
<span class="c1">#CALCULATION OF LINE RECEIVERS</span>
<span class="c1">###############################################################################</span>
<div class="viewcode-block" id="line_receivers">
<a class="viewcode-back" href="../../../acousticDE/FVMfunctions.html#acousticDE.FiniteVolumeMethod.FVMfunctions.line_receivers">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">line_receivers</span><span class="p">(</span><span class="n">room_length</span><span class="p">,</span> <span class="n">room_width</span><span class="p">,</span> <span class="n">coord_rec</span><span class="p">,</span> <span class="n">coord_source</span><span class="p">,</span> <span class="n">cell_center</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Definition of a line point receiver</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        room_length : float</span>
<span class="sd">            Length of the room</span>
<span class="sd">        room_width : float</span>
<span class="sd">            Width of the room</span>
<span class="sd">        coord_rec : list</span>
<span class="sd">            Coordinates of the receiver position</span>
<span class="sd">        coord_source : list</span>
<span class="sd">            Coordinates of the source position</span>
<span class="sd">        cell_center : array of floats</span>
<span class="sd">            The coordinates of the center of the cell element per each element</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        x_axis : array of floats</span>
<span class="sd">            Linspace on x_axis with distance dx</span>
<span class="sd">        y_axis : array of floats</span>
<span class="sd">            Linspace on y_axis with distance dy</span>
<span class="sd">        line_rec_x_idx_list : list</span>
<span class="sd">            Indexes of center cells close to the line receiver position in the x axis</span>
<span class="sd">        dist_x : array of floats </span>
<span class="sd">            Distance between each line receiver point cell and the source in the x axis</span>
<span class="sd">        line_rec_y_idx_list : list</span>
<span class="sd">            Indexes of center cells close to the line receiver position in the y axis</span>
<span class="sd">        dist_y : array of floats </span>
<span class="sd">            Distance between each line receiver point cell and the source in the y axis</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#Arange linespace lines</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="mf">0.5</span>
    <span class="n">x_axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">room_length</span><span class="o">+</span><span class="n">dx</span><span class="p">,</span><span class="n">dx</span><span class="p">)</span> <span class="c1">#lispace on x_axis with distance dx</span>
    <span class="n">y_axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">room_width</span><span class="o">+</span><span class="n">dx</span><span class="p">,</span><span class="n">dx</span><span class="p">)</span>

    <span class="c1">#RECEIVERS IN A X LINE</span>
    <span class="n">line_rec_x_idx_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">dist_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
    <span class="k">for</span> <span class="n">x_chang</span> <span class="ow">in</span> <span class="n">x_axis</span><span class="p">:</span>
        <span class="n">line_rec</span> <span class="o">=</span> <span class="p">[</span><span class="n">x_chang</span><span class="p">,</span> <span class="n">coord_rec</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">coord_rec</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
        <span class="c1">#Position of line_receiver is the centre of a cell</span>
        <span class="n">dist_line_rec_x</span> <span class="o">=</span>  <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="nb">abs</span><span class="p">(</span><span class="n">line_rec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">coord_source</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">line_rec</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">coord_source</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">line_rec</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">coord_source</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="c1">#distance between source and line_receiver</span>
        <span class="n">dist_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dist_x</span><span class="p">,</span> <span class="n">dist_line_rec_x</span><span class="p">)</span>  <span class="c1"># Append to the NumPy array</span>
        <span class="n">dist_line_rec_x_cc_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cell_center</span><span class="p">)):</span>
            <span class="n">dist_line_rec_x_cc</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">cell_center</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">line_rec</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
            <span class="n">dist_line_rec_x_cc_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dist_line_rec_x_cc</span><span class="p">)</span>
        <span class="n">line_rec_x_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dist_line_rec_x_cc_list</span><span class="p">)</span>
        <span class="n">line_rec_x_idx_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line_rec_x_idx</span><span class="p">)</span>   
    
    <span class="c1">#RECEIVERS IN A Y LINE</span>
    <span class="n">line_rec_y_idx_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">dist_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
    <span class="k">for</span> <span class="n">y_chang</span> <span class="ow">in</span> <span class="n">y_axis</span><span class="p">:</span>
        <span class="n">line_rec</span> <span class="o">=</span> <span class="p">[</span><span class="n">coord_rec</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y_chang</span><span class="p">,</span> <span class="n">coord_rec</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
        <span class="c1">#Position of line_receiver is the centre of a cell</span>
        <span class="n">dist_line_rec_y</span> <span class="o">=</span>  <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="nb">abs</span><span class="p">(</span><span class="n">line_rec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">coord_source</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">line_rec</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">coord_source</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">line_rec</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">coord_source</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="c1">#distance between source and line_receiver</span>
        <span class="n">dist_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dist_y</span><span class="p">,</span> <span class="n">dist_line_rec_y</span><span class="p">)</span>  <span class="c1"># Append to the NumPy array</span>
        <span class="n">dist_line_rec_y_cc_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cell_center</span><span class="p">)):</span>
            <span class="n">dist_line_rec_y_cc</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">cell_center</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">line_rec</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
            <span class="n">dist_line_rec_y_cc_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dist_line_rec_y_cc</span><span class="p">)</span>
        <span class="n">line_rec_y_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dist_line_rec_y_cc_list</span><span class="p">)</span>
        <span class="n">line_rec_y_idx_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line_rec_y_idx</span><span class="p">)</span>  
    
    <span class="k">return</span> <span class="n">x_axis</span><span class="p">,</span> <span class="n">y_axis</span><span class="p">,</span> <span class="n">line_rec_x_idx_list</span><span class="p">,</span> <span class="n">dist_x</span><span class="p">,</span> <span class="n">line_rec_y_idx_list</span><span class="p">,</span> <span class="n">dist_y</span></div>


<span class="c1">#%%</span>
<span class="c1">###############################################################################</span>
<span class="c1">#CALCULATION OF BETA_ZERO</span>
<span class="c1">###############################################################################</span>

<div class="viewcode-block" id="beta_zero_freq_fun">
<a class="viewcode-back" href="../../../acousticDE/FVMfunctions.html#acousticDE.FiniteVolumeMethod.FVMfunctions.beta_zero_freq_fun">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">beta_zero_freq_fun</span><span class="p">(</span><span class="n">boundary_areas</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">Dx</span><span class="p">,</span> <span class="n">interior_tet_sum</span><span class="p">,</span> <span class="n">cell_volume</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of factor beta_zero</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        boundary_areas : array of floats</span>
<span class="sd">            Product between the area and the correspondent absorption term for each surface for each tetrahedron</span>
<span class="sd">        dt : float</span>
<span class="sd">            Time step</span>
<span class="sd">        Dx : float</span>
<span class="sd">            Diffusion coefficient in the x direction (equal to the theoretical diffusion coefficient)</span>
<span class="sd">        interior_tet_sum : array of floats</span>
<span class="sd">            Sum of interior_tet per columns</span>
<span class="sd">        cell_volume : array of floats</span>
<span class="sd">            The volume of each element cell</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        beta_zero_freq : list</span>
<span class="sd">            Coefficient beta zero used in the calculation of the energy density per each frequency</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">beta_zero_freq</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">iBand</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">boundary_areas</span><span class="p">)):</span>
        <span class="c1">#print(iBand)</span>
        <span class="c1">#freq = center_freq[iBand]</span>
        <span class="c1">#print(boundary_areas[iBand])</span>
        <span class="n">beta_zero_element</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">dt</span><span class="o">*</span><span class="p">((</span><span class="n">Dx</span> <span class="o">*</span><span class="n">interior_tet_sum</span><span class="p">)</span> <span class="o">+</span> <span class="n">boundary_areas</span><span class="p">[</span><span class="n">iBand</span><span class="p">]),</span><span class="n">cell_volume</span><span class="p">)</span> <span class="c1">#my interpretation of the beta_zero</span>
        <span class="n">beta_zero_freq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">beta_zero_element</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">beta_zero_freq</span></div>


<span class="c1">#%%</span>
<span class="c1">###############################################################################</span>
<span class="c1">#MAIN CALCULATION - COMPUTING ENERGY DENSITY</span>
<span class="c1">############################################################################### </span>

<div class="viewcode-block" id="computing_energy_density">
<a class="viewcode-back" href="../../../acousticDE/FVMfunctions.html#acousticDE.FiniteVolumeMethod.FVMfunctions.computing_energy_density">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">computing_energy_density</span><span class="p">(</span><span class="n">nBands</span><span class="p">,</span> <span class="n">voluEl</span><span class="p">,</span> <span class="n">recording_steps</span><span class="p">,</span> <span class="n">beta_zero_freq</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">c0</span><span class="p">,</span> <span class="n">m_atm</span><span class="p">,</span> <span class="n">Dx</span><span class="p">,</span> <span class="n">interior_tet</span><span class="p">,</span> <span class="n">cell_volume</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">cl_tet_r_keys</span><span class="p">,</span> <span class="n">total_weights_r</span><span class="p">,</span> <span class="n">tcalc</span><span class="p">,</span> <span class="n">cl_tet_s_keys</span><span class="p">,</span> <span class="n">source1</span><span class="p">,</span> <span class="n">total_weights_s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">sourceon_time</span><span class="p">,</span> <span class="n">rho</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computation of energy density</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        nBands : int</span>
<span class="sd">            Number of frequency bands</span>
<span class="sd">        voluEl : array of int</span>
<span class="sd">            Indeces of all the bolume elements (tetrahedra) in the mesh</span>
<span class="sd">        recording_steps : int </span>
<span class="sd">            Number of time steps</span>
<span class="sd">        beta_zero_freq : list</span>
<span class="sd">            Coefficient beta zero used in the calculation of the energy density per each frequency</span>
<span class="sd">        dt : float</span>
<span class="sd">            Time step</span>
<span class="sd">        c0 : int </span>
<span class="sd">            Speed of sound</span>
<span class="sd">        m_atm : float</span>
<span class="sd">            Air absorption coefficient</span>
<span class="sd">        Dx : float</span>
<span class="sd">            Diffusion coefficient in the x direction (equal to the theoretical diffusion coefficient)</span>
<span class="sd">        interior_tet : array of floats</span>
<span class="sd">            Matrix of tetrahedron per tetrahedron of the division between shared area and shared distance</span>
<span class="sd">        cell_volume : array of floats </span>
<span class="sd">            The volume of each element cell</span>
<span class="sd">        s : array of floats </span>
<span class="sd">            Matrix of tretrahedron central points inserting source energy</span>
<span class="sd">        cl_tet_r_keys : dict keys</span>
<span class="sd">            Closest tetrahedrons indeces to the receiver</span>
<span class="sd">        total_weights_r : dict</span>
<span class="sd">            Weights for each 4 closest points to the receiver position for interpolation</span>
<span class="sd">        tcalc : str</span>
<span class="sd">            Type of calculation; &quot;decay&quot; if the source switches off and &quot;stationarysource&quot; if the source is stationary</span>
<span class="sd">        cl_tet_s_keys : dict keys</span>
<span class="sd">            Closest tetrahedrons indeces to the source</span>
<span class="sd">        total_weights_s : dict</span>
<span class="sd">            Weights for each 4 closest points to the source position for interpolation</span>
<span class="sd">        source1 : array of floats</span>
<span class="sd">            Energy density of source number 1 at each time step position</span>
<span class="sd">        total_weights_s : dict</span>
<span class="sd">            Weights for each 4 closest points to the source position for interpolation</span>
<span class="sd">        t : array of floats</span>
<span class="sd">            Time array of time steps</span>
<span class="sd">        sourceon_time : float</span>
<span class="sd">            Time that the source stays on</span>
<span class="sd">        rho : float</span>
<span class="sd">            Density of air</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        w_new_band : list of arrays</span>
<span class="sd">            Energy density at the time step n+1 at each centre cell per each frequency band</span>
<span class="sd">        w_rec_band : list of arrays</span>
<span class="sd">            Energy density over time at the receiver position per each frequency band</span>
<span class="sd">        w_rec_off_band : list of arrays</span>
<span class="sd">            Energy density over time after the source is switched off at the receiver position per each frequency band</span>
<span class="sd">        w_rec_off_deriv_band : list of arrays</span>
<span class="sd">            Derivative of the energy density over time after the source is switched off at the receiver position per each frequency band</span>
<span class="sd">        p_rec_off_deriv_band : list of arrays</span>
<span class="sd">            Derivative of the pressure over time after the source is switched off at the receiver position per each frequency band</span>
<span class="sd">        idx_w_rec : int</span>
<span class="sd">            Time index at which the source is switched off</span>
<span class="sd">        t_off : array of floats</span>
<span class="sd">            Time array after the source is switched off</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">w_new_band</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">w_rec_band</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">w_rec_off_band</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">w_rec_off_deriv_band</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">p_rec_off_deriv_band</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">iBand</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nBands</span><span class="p">):</span>
        
        <span class="n">w_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">voluEl</span><span class="p">))</span> <span class="c1">#unknown w at new time level (n+1)</span>
        <span class="c1">#w_old = np.zeros(len(voluEl)) </span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">w_new</span> <span class="c1">#w at n level</span>
        <span class="n">w_old</span> <span class="o">=</span> <span class="n">w</span> <span class="c1">#w_old at n-1 level</span>
        <span class="c1">#w[source_idx] = w1 #w (m time step) at source position -&gt; impulse source</span>
        
        <span class="n">w_rec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">recording_steps</span><span class="p">)</span> <span class="c1">#energy density at the receiver</span>
        
        <span class="c1">#Computing w;</span>
        <span class="k">for</span> <span class="n">steps</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">recording_steps</span><span class="p">):</span>
            <span class="c1">#Compute w at inner mesh points</span>
            <span class="c1">#time_steps = steps*dt #total time for the calculation</span>
            
            <span class="c1">#Computing w_new (w at n+1 time step)</span>
                        
            <span class="n">w_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">w_old</span><span class="p">,(</span><span class="mi">1</span><span class="o">-</span><span class="n">beta_zero_freq</span><span class="p">[</span><span class="n">iBand</span><span class="p">]))),(</span><span class="mi">1</span><span class="o">+</span><span class="n">beta_zero_freq</span><span class="p">[</span><span class="n">iBand</span><span class="p">]))</span> <span class="o">-</span> \
                <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">c0</span><span class="o">*</span><span class="n">m_atm</span><span class="o">*</span><span class="n">w</span><span class="p">),(</span><span class="mi">1</span><span class="o">+</span><span class="n">beta_zero_freq</span><span class="p">[</span><span class="n">iBand</span><span class="p">]))</span> <span class="o">+</span> \
                    <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">Dx</span><span class="o">*</span><span class="p">(</span><span class="n">interior_tet</span><span class="nd">@w</span><span class="p">)),</span><span class="n">cell_volume</span><span class="p">),(</span><span class="mi">1</span><span class="o">+</span><span class="n">beta_zero_freq</span><span class="p">[</span><span class="n">iBand</span><span class="p">]))</span> <span class="o">+</span> \
                        <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">s</span><span class="p">),(</span><span class="mi">1</span><span class="o">+</span><span class="n">beta_zero_freq</span><span class="p">[</span><span class="n">iBand</span><span class="p">]))</span> <span class="c1">#The absorption term is part of beta_zero</span>
                         
            <span class="c1">#Update w before next step</span>
            <span class="n">w_old</span> <span class="o">=</span> <span class="n">w</span> <span class="c1">#The w at n step becomes the w at n-1 step</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">w_new</span> <span class="c1">#The w at n+1 step becomes the w at n step</span>
            
            <span class="c1">#INTERPOLATION WITH N CELL CENTRES OR 4 CELL CENTRES</span>
            <span class="k">for</span> <span class="n">tet_r</span> <span class="ow">in</span> <span class="n">cl_tet_r_keys</span><span class="p">:</span>
                <span class="n">w_rec</span><span class="p">[</span><span class="n">steps</span><span class="p">]</span> <span class="o">+=</span> <span class="n">w_new</span><span class="p">[</span><span class="n">tet_r</span><span class="p">]</span> <span class="o">*</span><span class="n">total_weights_r</span><span class="p">[</span><span class="n">tet_r</span><span class="p">]</span>   
            
            <span class="k">if</span> <span class="n">tcalc</span> <span class="o">==</span> <span class="s2">&quot;decay&quot;</span><span class="p">:</span>
                <span class="c1">#INTERPOLATION WITH N CELL CENTRES OR 4 CELL CENTRES</span>
                <span class="k">for</span> <span class="n">tet_s</span> <span class="ow">in</span> <span class="n">cl_tet_s_keys</span><span class="p">:</span>
                     <span class="n">s</span><span class="p">[</span><span class="n">tet_s</span><span class="p">]</span> <span class="o">=</span> <span class="n">source1</span><span class="p">[</span><span class="n">steps</span><span class="p">]</span> <span class="o">*</span><span class="n">total_weights_s</span><span class="p">[</span><span class="n">tet_s</span><span class="p">]</span>
            
            <span class="k">if</span> <span class="n">tcalc</span> <span class="o">==</span> <span class="s2">&quot;stationarysource&quot;</span><span class="p">:</span>
                <span class="c1">#ORIGINAL</span>
                <span class="c1">#s[source_idx] = source1[0]</span>
                
                <span class="c1">#INTERPOLATION SOURCE</span>
                <span class="k">for</span> <span class="n">tet_s</span> <span class="ow">in</span> <span class="n">cl_tet_s_keys</span><span class="p">:</span>
                     <span class="n">s</span><span class="p">[</span><span class="n">tet_s</span><span class="p">]</span> <span class="o">=</span> <span class="n">source1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span><span class="n">total_weights_s</span><span class="p">[</span><span class="n">tet_s</span><span class="p">]</span>
            
            <span class="n">idx_w_rec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="n">sourceon_time</span><span class="p">))</span> <span class="c1">#index at which the t array is equal to the sourceon_time; I want the RT to calculate from when the source stops.</span>
            <span class="n">w_rec_off</span> <span class="o">=</span> <span class="n">w_rec</span><span class="p">[</span><span class="n">idx_w_rec</span><span class="p">:]</span>
            <span class="n">p_rec_off</span> <span class="o">=</span> <span class="p">(</span><span class="n">w_rec</span><span class="p">[</span><span class="n">idx_w_rec</span><span class="p">:])</span><span class="o">*</span><span class="n">rho</span><span class="o">*</span><span class="n">c0</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">t_off</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">idx_w_rec</span><span class="p">:]</span>
            
            <span class="c1">#Envelope of Impulse response from the energy density</span>
            <span class="n">w_rec_off_deriv</span> <span class="o">=</span> <span class="n">w_rec_off</span> <span class="c1">#initialising an array of derivative equal to the w_rec_off -&gt; this will be the impulse response after modifying it</span>
            <span class="n">w_rec_off_deriv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">w_rec_off_deriv</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">#delete the first element of the array -&gt; this means shifting the array one step before and therefore do a derivation</span>
            <span class="n">w_rec_off_deriv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">w_rec_off_deriv</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="c1">#add a zero in the last element of the array -&gt; for derivation and to have the same length as previously</span>
            <span class="c1">#impulse = ((w_rec_off - w_rec_off_deriv))/dt#/(rho*c0**2) #This is the difference between the the energy density and the impulse response </span>
            
            <span class="c1">#Envelope of Impulse response from the pressure</span>
            <span class="n">p_rec_off_deriv</span> <span class="o">=</span> <span class="n">p_rec_off</span> <span class="c1">#initialising an array of derivative equal to the w_rec_off -&gt; this will be the impulse response after modifying it</span>
            <span class="n">p_rec_off_deriv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">p_rec_off_deriv</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">#delete the first element of the array -&gt; this means shifting the array one step before and therefore do a derivation</span>
            <span class="n">p_rec_off_deriv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p_rec_off_deriv</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="c1">#add a zero in the last element of the array -&gt; for derivation and to have the same length as previously</span>
            
            <span class="c1">#print(time_steps)</span>
            
        <span class="n">percentDone</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="mi">100</span><span class="o">*</span><span class="n">iBand</span><span class="o">/</span><span class="n">nBands</span><span class="p">);</span>
        <span class="c1">#if (percentDone &gt; curPercent):</span>
        <span class="nb">print</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">percentDone</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="si">% o</span><span class="s2">f main calculation completed&quot;</span><span class="p">)</span>
            <span class="c1">#curPercent += 1;</span>
    
        <span class="n">w_new_band</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">w_new</span><span class="p">)</span>
        <span class="n">w_rec_band</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">w_rec</span><span class="p">)</span>
        <span class="n">w_rec_off_band</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">w_rec_off</span><span class="p">)</span>
        <span class="n">w_rec_off_deriv_band</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">w_rec_off_deriv</span><span class="p">)</span>
        <span class="n">p_rec_off_deriv_band</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p_rec_off_deriv</span><span class="p">)</span>
        
        <span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">w_new_band</span><span class="p">,</span> <span class="n">w_rec_band</span><span class="p">,</span> <span class="n">w_rec_off_band</span><span class="p">,</span> <span class="n">w_rec_off_deriv_band</span><span class="p">,</span> <span class="n">p_rec_off_deriv_band</span><span class="p">,</span> <span class="n">idx_w_rec</span><span class="p">,</span> <span class="n">t_off</span></div>



<span class="c1">#%%</span>
<span class="c1">###############################################################################</span>
<span class="c1">#POST-PROCESS</span>
<span class="c1">###############################################################################</span>

<div class="viewcode-block" id="freq_parameters">
<a class="viewcode-back" href="../../../acousticDE/FVMfunctions.html#acousticDE.FiniteVolumeMethod.FVMfunctions.freq_parameters">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">freq_parameters</span><span class="p">(</span><span class="n">nBands</span><span class="p">,</span> <span class="n">line_rec_x_idx_list</span><span class="p">,</span> <span class="n">w_new_band</span><span class="p">,</span> <span class="n">line_rec_y_idx_list</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">c0</span><span class="p">,</span> <span class="n">Ws</span><span class="p">,</span> <span class="n">dist_x</span><span class="p">,</span> <span class="n">dist_y</span><span class="p">,</span> <span class="n">pRef</span><span class="p">,</span> <span class="n">w_rec_band</span><span class="p">,</span> <span class="n">w_rec_off_band</span><span class="p">,</span> <span class="n">tcalc</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">idx_w_rec</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">Eq_A</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">dist_sr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computation of sound presure level and reverberation time parameters</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        nBands : int</span>
<span class="sd">            Number of frequency bands</span>
<span class="sd">        line_rec_x_idx_list : list</span>
<span class="sd">            Indexes of center cells close to the line receiver position in the x axis</span>
<span class="sd">        w_new_band : list of arrays</span>
<span class="sd">            Energy density at the time step n+1 at each centre cell per each frequency band</span>
<span class="sd">        line_rec_y_idx_list : list</span>
<span class="sd">            Indexes of center cells close to the line receiver position in the y axis</span>
<span class="sd">        rho : float </span>
<span class="sd">            Density of air</span>
<span class="sd">        c0 : int</span>
<span class="sd">            Speed of sound</span>
<span class="sd">        Ws : float</span>
<span class="sd">            Power of the source</span>
<span class="sd">        dist_x : array of floats</span>
<span class="sd">            Distance between each line receiver point cell and the source in the x axis</span>
<span class="sd">        dist_y : array of floats</span>
<span class="sd">            Distance between each line receiver point cell and the source in the y axis</span>
<span class="sd">        pRef : float</span>
<span class="sd">            Reference pressure</span>
<span class="sd">        w_rec_band : list of arrays</span>
<span class="sd">            Energy density over time at the receiver position per each frequency band</span>
<span class="sd">        w_rec_off_band : list of arrays</span>
<span class="sd">            Energy density over time after the source is switched off at the receiver position per each frequency band</span>
<span class="sd">        tcalc : str</span>
<span class="sd">            Type of calculation; &quot;decay&quot; if the source switches off and &quot;stationarysource&quot; if the source is stationary</span>
<span class="sd">        t : array of floats</span>
<span class="sd">            Time array of time steps</span>
<span class="sd">        idx_w_rec : int</span>
<span class="sd">            Time index at which the source is switched off</span>
<span class="sd">        V : float</span>
<span class="sd">            Volume of the room</span>
<span class="sd">        Eq_A : array of floats</span>
<span class="sd">            Equivalent absorption area</span>
<span class="sd">        S : float</span>
<span class="sd">            Total surface are of the room</span>
<span class="sd">        dist_sr : float</span>
<span class="sd">            Distance between source and receiver position</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        w_rec_x_band : list of arrays</span>
<span class="sd">            Energy density over time at the each line point receiver position in the x axis per each frequency band</span>
<span class="sd">        w_rec_y_band : list of arrays</span>
<span class="sd">            Energy density over time at the each line point receiver position in the y axis per each frequency band</span>
<span class="sd">        spl_stat_x_band : list of array</span>
<span class="sd">            Total sound pressure level (direct field plus reverberant) over time at the each line point receiver position in the x axis per each frequency band</span>
<span class="sd">        spl_stat_y_band : list of arrays</span>
<span class="sd">            Total sound pressure level (direct field plus reverberant) over time at the each line point receiver position in the y axis per each frequency band</span>
<span class="sd">        spl_r_band : list of arrays</span>
<span class="sd">            Sound pressure level over time at the receiver position per each frequency band</span>
<span class="sd">        spl_r_off_band : list of arrays</span>
<span class="sd">            Sound pressure level over time after the source is switched off at the receiver position per each frequency band</span>
<span class="sd">        spl_r_norm_band : list of arrays</span>
<span class="sd">            Sound pressure level over time at the receiver position per each frequency band normalised to its maximum level</span>
<span class="sd">        sch_db_band : list of arrays</span>
<span class="sd">            Energy density over time after the source is switched off at the receiver position per each frequency band</span>
<span class="sd">        t30_band : array of floats</span>
<span class="sd">            Reverberation time T30 per each frequency band</span>
<span class="sd">        edt_band : array of floats</span>
<span class="sd">            Early decay time per each frequency band</span>
<span class="sd">        c80_band : array of floats </span>
<span class="sd">            Clarity per each frequency band</span>
<span class="sd">        d50_band : array of floats </span>
<span class="sd">            Definition per each frequency band</span>
<span class="sd">        ts_band : array of floats</span>
<span class="sd">            Centre time per each frequency band</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">w_rec_x_band</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">w_rec_y_band</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">spl_stat_x_band</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">spl_stat_y_band</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">spl_r_band</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">spl_r_off_band</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">spl_r_norm_band</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">t30_band</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">edt_band</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">c80_band</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">d50_band</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">ts_band</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">sch_db_band</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">iBand</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nBands</span><span class="p">):</span>
        
        <span class="n">w_rec_x_end</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="k">for</span> <span class="n">xr</span> <span class="ow">in</span> <span class="n">line_rec_x_idx_list</span><span class="p">:</span>
            <span class="n">w_rec_x</span> <span class="o">=</span> <span class="n">w_new_band</span><span class="p">[</span><span class="n">iBand</span><span class="p">][</span><span class="n">xr</span><span class="p">]</span>
            <span class="n">w_rec_x_end</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">w_rec_x_end</span><span class="p">,</span> <span class="n">w_rec_x</span><span class="p">)</span>
            
        <span class="n">w_rec_y_end</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="k">for</span> <span class="n">yr</span> <span class="ow">in</span> <span class="n">line_rec_y_idx_list</span><span class="p">:</span>
            <span class="n">w_rec_y</span> <span class="o">=</span> <span class="n">w_new_band</span><span class="p">[</span><span class="n">iBand</span><span class="p">][</span><span class="n">yr</span><span class="p">]</span>
            <span class="n">w_rec_y_end</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">w_rec_y_end</span><span class="p">,</span> <span class="n">w_rec_y</span><span class="p">)</span>
    
        <span class="n">spl_stat_x</span> <span class="o">=</span> <span class="mi">10</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">rho</span><span class="o">*</span><span class="n">c0</span><span class="o">*</span><span class="p">(((</span><span class="n">Ws</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="n">dist_x</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span> <span class="o">+</span> <span class="p">((</span><span class="nb">abs</span><span class="p">(</span><span class="n">w_rec_x_end</span><span class="p">)</span><span class="o">*</span><span class="n">c0</span><span class="p">)))</span><span class="o">/</span><span class="p">(</span><span class="n">pRef</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">spl_stat_y</span> <span class="o">=</span> <span class="mi">10</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">rho</span><span class="o">*</span><span class="n">c0</span><span class="o">*</span><span class="p">(((</span><span class="n">Ws</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="n">dist_y</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span> <span class="o">+</span> <span class="p">((</span><span class="nb">abs</span><span class="p">(</span><span class="n">w_rec_y_end</span><span class="p">)</span><span class="o">*</span><span class="n">c0</span><span class="p">)))</span><span class="o">/</span><span class="p">(</span><span class="n">pRef</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="c1">#It should be the spl stationary </span>
    
        <span class="c1">#press_r = ((abs(w_rec_band[iBand]))*rho*(c0**2)) #pressure at the receiver</span>
        <span class="n">spl_r</span> <span class="o">=</span> <span class="mi">10</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(((</span><span class="nb">abs</span><span class="p">(</span><span class="n">w_rec_band</span><span class="p">[</span><span class="n">iBand</span><span class="p">]))</span><span class="o">*</span><span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">c0</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="n">pRef</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="c1">#,where=press_r&gt;0, sound pressure level at the receiver</span>
        <span class="n">spl_r_off</span> <span class="o">=</span> <span class="mi">10</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(((</span><span class="nb">abs</span><span class="p">(</span><span class="n">w_rec_off_band</span><span class="p">[</span><span class="n">iBand</span><span class="p">]))</span><span class="o">*</span><span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">c0</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="n">pRef</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
        
        <span class="n">spl_r_norm</span> <span class="o">=</span> <span class="mi">10</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">((((</span><span class="nb">abs</span><span class="p">(</span><span class="n">w_rec_band</span><span class="p">[</span><span class="n">iBand</span><span class="p">]))</span><span class="o">*</span><span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">c0</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="n">pRef</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(((</span><span class="nb">abs</span><span class="p">(</span><span class="n">w_rec_band</span><span class="p">[</span><span class="n">iBand</span><span class="p">]))</span><span class="o">*</span><span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">c0</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="n">pRef</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span> <span class="c1">#normalised to maximum to 0dB</span>

        <span class="n">schroeder</span> <span class="o">=</span> <span class="n">w_rec_off_band</span><span class="p">[</span><span class="n">iBand</span><span class="p">]</span> <span class="c1">#energy_r_rev_cum[::-1] #reverting the array again -&gt; creating the schroder decay</span>
        <span class="n">sch_db</span> <span class="o">=</span> <span class="mf">10.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">schroeder</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="n">schroeder</span><span class="p">))</span> <span class="c1">#level of the array: schroeder decay</span>
        
        <span class="k">if</span> <span class="n">tcalc</span> <span class="o">==</span> <span class="s2">&quot;decay&quot;</span><span class="p">:</span>
            <span class="n">t30</span> <span class="o">=</span> <span class="n">t60_decay</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">sch_db</span><span class="p">,</span> <span class="n">idx_w_rec</span><span class="p">,</span> <span class="n">rt</span><span class="o">=</span><span class="s1">&#39;t30&#39;</span><span class="p">)</span> <span class="c1">#called function for calculation of t60 [s]</span>
            <span class="n">edt</span> <span class="o">=</span> <span class="n">t60_decay</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">sch_db</span><span class="p">,</span> <span class="n">idx_w_rec</span><span class="p">,</span> <span class="n">rt</span><span class="o">=</span><span class="s1">&#39;edt&#39;</span><span class="p">)</span> <span class="c1">#called function for calculation of edt [s]</span>
            <span class="c1">#Eq_A = 0.16*V/t60 #equivalent absorption area defined from the RT </span>
            <span class="n">c80</span> <span class="o">=</span> <span class="n">clarity</span><span class="p">(</span><span class="n">t30</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">Eq_A</span><span class="p">[</span><span class="n">iBand</span><span class="p">],</span> <span class="n">S</span><span class="p">,</span> <span class="n">c0</span><span class="p">,</span> <span class="n">dist_sr</span><span class="p">)</span> <span class="c1">#called function for calculation of c80 [dB]</span>
            <span class="n">d50</span> <span class="o">=</span> <span class="n">definition</span><span class="p">(</span><span class="n">t30</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">Eq_A</span><span class="p">[</span><span class="n">iBand</span><span class="p">],</span> <span class="n">S</span><span class="p">,</span> <span class="n">c0</span><span class="p">,</span> <span class="n">dist_sr</span><span class="p">)</span> <span class="c1">#called function for calculation of d50 [%]</span>
            <span class="n">ts</span> <span class="o">=</span> <span class="n">centretime</span><span class="p">(</span><span class="n">t30</span><span class="p">,</span> <span class="n">Eq_A</span><span class="p">[</span><span class="n">iBand</span><span class="p">],</span> <span class="n">S</span><span class="p">)</span> <span class="c1">#called function for calculation of ts [ms]</span>
            
            <span class="n">t30_band</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t30</span><span class="p">)</span>
            <span class="n">edt_band</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edt</span><span class="p">)</span>
            <span class="n">c80_band</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c80</span><span class="p">)</span>
            <span class="n">d50_band</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d50</span><span class="p">)</span>
            <span class="n">ts_band</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
            
        <span class="n">w_rec_x_band</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">w_rec_x_end</span><span class="p">)</span>
        <span class="n">w_rec_y_band</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">w_rec_y_end</span><span class="p">)</span>
        <span class="n">spl_stat_x_band</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spl_stat_x</span><span class="p">)</span>
        <span class="n">spl_stat_y_band</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spl_stat_y</span><span class="p">)</span>
        <span class="n">spl_r_band</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spl_r</span><span class="p">)</span>
        <span class="n">spl_r_off_band</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spl_r_off</span><span class="p">)</span>
        <span class="n">spl_r_norm_band</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spl_r_norm</span><span class="p">)</span>
        <span class="n">sch_db_band</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sch_db</span><span class="p">)</span>
    
    <span class="n">spl_r_off_band</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">spl_r_off_band</span><span class="p">)</span>
    <span class="n">t30_band</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">t30_band</span><span class="p">)</span>
    <span class="n">edt_band</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">edt_band</span><span class="p">)</span>
    <span class="n">c80_band</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">c80_band</span><span class="p">)</span>
    <span class="n">d50_band</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">d50_band</span><span class="p">)</span>
    <span class="n">ts_band</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ts_band</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">w_rec_x_band</span><span class="p">,</span> <span class="n">w_rec_y_band</span><span class="p">,</span> <span class="n">spl_stat_x_band</span><span class="p">,</span> <span class="n">spl_stat_y_band</span><span class="p">,</span> <span class="n">spl_r_band</span><span class="p">,</span> <span class="n">spl_r_off_band</span><span class="p">,</span> <span class="n">spl_r_norm_band</span><span class="p">,</span> <span class="n">sch_db_band</span><span class="p">,</span> <span class="n">t30_band</span><span class="p">,</span> <span class="n">edt_band</span><span class="p">,</span> <span class="n">c80_band</span><span class="p">,</span> <span class="n">d50_band</span><span class="p">,</span> <span class="n">ts_band</span></div>


<span class="c1">#%%</span>
<span class="c1">###############################################################################</span>
<span class="c1">#SAVING</span>
<span class="c1">###############################################################################</span>

<span class="c1"># Save all variables to a file</span>
<div class="viewcode-block" id="save_fvm">
<a class="viewcode-back" href="../../../acousticDE/FVMfunctions.html#acousticDE.FiniteVolumeMethod.FVMfunctions.save_fvm">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">save_fvm</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="n">variables</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Saving of variables</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        filename : str</span>
<span class="sd">            Name of the file to save the results</span>
<span class="sd">        variables : dict</span>
<span class="sd">            Compilation of all the variables of the overall simulation</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="c1"># Filter out modules, functions, and other unsupported types</span>
        <span class="n">filtered_variables</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Check if the object can be pickled</span>
                <span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="c1"># Exclude some types explicitly known to cause issues</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">k</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;__&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">ModuleType</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">FunctionType</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">BuiltinFunctionType</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">LambdaType</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">MethodType</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">MappingProxyType</span><span class="p">)):</span>
                    <span class="n">filtered_variables</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Could not pickle </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">filtered_variables</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span></div>



<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="c1">#start time of calculation</span>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Ilaria Fichera.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>